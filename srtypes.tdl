
;;; Hey, emacs (1), this is -*- mode:tdl; Coding: utf-8; -*-
;;; 
;;; Montserrat Marimon
;;;
;;; srtypes.tdl: phrase structure and construction types for the SRG
 
; --- 1. Phrase structure types

; --- Basic phrase types
 
basic-headed-phrase := phrase & 
  [ SYNSEM.LOCAL [ COORD #coord,
                   COORD-STRAT #coord-strat,
                   CAT.HEAD head ],
    HEAD-DTR.SYNSEM.LOCAL local & [ COORD #coord & -,
                                    COORD-STRAT #coord-strat ] ].

headed-phrase := basic-headed-phrase & 
  [ SYNSEM.LOCAL [ CAT.HEAD #head ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD #head ] ].

non-headed-phrase := phrase.

phrasal := phrase &
  [ SYNSEM phr-synsem ]
""" Most but not all phrases have SYNSEM phr-synsem
""".


head-compositional := headed-phrase &
  [ C-CONT.HOOK #hook,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook ]
"""
; C-CONT is the semantic contribution of the phrase itself. The hook of the phrase is 
; identified with the hook of C-CONT (which is possibly but not necessarily identified 
; with the hook of one of the daughters. The rels and hcons of the phrase result from 
; appending the rels and hcons of C-CONT and the rels and hcons of the daughters.
; Head-compositional phrases identify the syntactic head daughter as the semantic head.
""".


basic-unary-phrase := phrase &
  [ STEM #stem,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                               LAST #last ],
                        HCONS [ LIST #scfirst,
                                LAST #sclast ] ],
    C-CONT [ RELS [ LIST #first,
                    LAST #middle ],
             HCONS [ LIST #scfirst,
                     LAST #scmiddle ] ],
    ARGS < sign & [ STEM #stem,
                    SYNSEM.LOCAL local &
                                 [ CONT [ RELS [ LIST #middle,
                                                 LAST #last ],
                                          HCONS [ LIST #scmiddle,
                                                  LAST #sclast ] ] ] ] > ].

norm-unary-phrase := basic-unary-phrase &
  [ SYNSEM.PUNCT #punct,
    ARGS < [ SYNSEM.PUNCT #punct ] > ].

unary-phrase := norm-unary-phrase &
  [ INFLECTED +,
    ARGS < [ INFLECTED + ] > ].

very-basic-binary-phrase := phrase &
  [ ARGS < sign, sign >,
    NON-HEAD-DTR sign ].

basic-binary-phrase := very-basic-binary-phrase & 
  [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                               LAST #last ],
                        HCONS [ LIST #scfirst,
                                LAST #sclast ] ],
    C-CONT [ RELS [ LIST #first,
                    LAST #middle1 ],
             HCONS [ LIST #scfirst,
                     LAST #scmiddle1 ] ],
    ARGS < [ SYNSEM.LOCAL local &
                          [ CONT [ RELS [ LIST #middle1,
                                          LAST #middle2 ],
                                   HCONS [ LIST #scmiddle1,
                                           LAST #scmiddle2 ] ] ] ],
           [ SYNSEM.LOCAL local &
                          [ CONT [ RELS [ LIST #middle2,
                                          LAST #last ],
                                   HCONS [ LIST #scmiddle2,
                                           LAST #sclast ] ] ] ] > ].

explt-binary-phrase := very-basic-binary-phrase & 
  [ INFLECTED +,
    SYNSEM [ PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct ],
             LOCAL.CONT [ RELS [ LIST #first,
                                 LAST #last ],
                          HCONS [ LIST #scfirst,
                                  LAST #sclast ] ] ],
    C-CONT [ RELS [ LIST #first,
                    LAST #middle ],
             HCONS [ LIST #scfirst,
                     LAST #scmiddle ] ],
    ARGS < [ INFLECTED +,
             SYNSEM.PUNCT.LPUNCT #lpunct ],
           [ INFLECTED +,
             SYNSEM [ PUNCT.RPUNCT #rpunct,
                      LOCAL local &
                            [ CONT [ RELS [ LIST #middle,
                                            LAST #last ],
                                     HCONS [ LIST #scmiddle,
                                             LAST #sclast ] ] ] ] ] > ].

binary-punct-phrase := basic-binary-phrase &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT #rpunct ],
    ARGS < [ SYNSEM.PUNCT.LPUNCT #lpunct ],
           [ SYNSEM.PUNCT.RPUNCT #rpunct ] > ].

binary-phrase := basic-binary-phrase &
  [ INFLECTED +,
    SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT #rpunct ],
    ARGS < [ INFLECTED +,
             SYNSEM.PUNCT.LPUNCT #lpunct  ],
           [ INFLECTED +, 
             SYNSEM.PUNCT.RPUNCT #rpunct ] > ].

basic-binary-headed-phrase := headed-phrase & basic-binary-phrase.

binary-headed-phrase := basic-binary-headed-phrase & binary-phrase.

basic-ternary-phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
			       LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
    C-CONT [ RELS [ LIST #middle3,
		    LAST #last ],
	     HCONS [ LIST #scmiddle3,
		     LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS [ LIST #first,
						 LAST #middle1 ],
					  HCONS [ LIST #scfirst,
						  LAST #scmiddle1 ] ] ] ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS [ LIST #middle1,
					         LAST #middle2 ],
					  HCONS [ LIST #scmiddle1,
						  LAST #scmiddle2 ] ] ] ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS [ LIST #middle2,
						 LAST #middle3 ],
					  HCONS [ LIST #scmiddle2,
						  LAST #scmiddle3 ] ] ] ] > ].

ternary-punct-phrase := basic-ternary-phrase &
  [ SYNSEM.PUNCT [ LPUNCT #lpunct,
                   RPUNCT #rpunct ],
    ARGS < [ SYNSEM.PUNCT.LPUNCT #lpunct ],
           [ ],
           [ SYNSEM.PUNCT.RPUNCT #rpunct ] > ].

ternary-phrase := ternary-punct-phrase & 
  [ INFLECTED +,
    ARGS < [ INFLECTED + ],
           [ INFLECTED + ],
           [ INFLECTED + ] > ].

ternary-headed-phrase := headed-phrase & ternary-phrase.

basic_quad_phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS  [ LIST #first,
				LAST #last ],
			HCONS [ LIST #scfirst,
				LAST #sclast ] ],
    C-CONT [ RELS  [ LIST #first,
		     LAST #middle1 ],
	     HCONS [ LIST #scfirst,
		     LAST #scmiddle1 ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS  [ LIST #middle1,
						  LAST #middle2 ],
					  HCONS [ LIST #scmiddle1,
						  LAST #scmiddle2 ] ] ] ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS  [ LIST #middle2,
						  LAST #middle3 ],
					  HCONS [ LIST #scmiddle2,
						  LAST #scmiddle3 ] ] ] ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS  [ LIST #middle3,
						  LAST #middle4 ],
					  HCONS [ LIST #scmiddle3,
						  LAST #scmiddle4 ] ] ] ],
	   sign & [ SYNSEM.LOCAL local &
				 [ CONT [ RELS  [ LIST #middle4,
						  LAST #last ],
					  HCONS [ LIST #scmiddle4,
						  LAST #sclast ] ] ] ] > ].

quad_phrase := basic_quad_phrase &
  [ INFLECTED +,
    ARGS < [ INFLECTED + ],
           [ INFLECTED + ],
           [ INFLECTED + ],
	   [ INFLECTED + ] > ].

head-only := unary-phrase & headed-phrase &
  [ SYNSEM.LOCAL.STR.HEADED solely,
    HEAD-DTR #head & 
             [ SYNSEM.LOCAL.STR.HEADING solely ],
    ARGS < #head > ].

head-initial := binary-headed-phrase &
  [ SYNSEM.LOCAL.STR.HEADED left,
    HEAD-DTR #head & 
             [ SYNSEM.LOCAL.STR.HEADING left ],
    NON-HEAD-DTR #non-head,
    ARGS < #head, #non-head > ].

non_str-head-initial := binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #head, #non-head > ].

basic-head-final := basic-binary-headed-phrase &
  [ SYNSEM.LOCAL.STR.HEADED right,
    HEAD-DTR #head & 
             [ SYNSEM.LOCAL.STR.HEADING right ],
    NON-HEAD-DTR #non-head,
    ARGS < #non-head, #head > ].

head-final := basic-head-final & binary-headed-phrase.


binary-rule-left-to-right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ]
"""
; For more efficient parsing, designate one argument or the other
; as the KEY-ARG: that which should be unified with first.
""".

binary-rule-right-to-left := rule &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

ternary_rule_left_to_right := rule &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] , [ KEY-ARG bool ] > ].

quad_rule_left_to_right := rule &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ], [ KEY-ARG bool ], [ KEY-ARG bool ] > ]
"""
; *** moved key from daughter 1 to daughter 2
""".


head-nexus-rel-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.REL #rel,
    HEAD-DTR.SYNSEM.NON-LOCAL.REL #rel ]
"""
; head/nexus phrases pass up the REL and QUE values of the head daughter, 
; which has amalgamated the REL and QUE values of its arguments to the mother
""".

head-nexus-que-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.QUE #que,
    HEAD-DTR.SYNSEM.NON-LOCAL.QUE #que ].

head-nexus-phrase := head-nexus-rel-phrase & head-nexus-que-phrase.

head-valence-phrase := head-nexus-phrase &
  [ SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash ]
"""
; In a head/local dependent phrase, the SLASH feature of the mother is token-identical 
; to that of the head daughter, which has already amalgamated the SLASH values of its arguments. 
""".


; --- clause types

non-clause := head-nexus-phrase &
  [ SYNSEM.LOCAL.CAT.MC na ].

clause := phrasal &
  [ SYNSEM.LOCAL.CAT [ HEAD +vc ] ].

mc-fillhead-phrase := headed-phrase &
  [ SYNSEM [ LOCAL.CONT.HOOK.XARG #xarg,
	     NON-LOCAL [ SLASH 0-dlist,
			 QUE 0-dlist ] ],
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #xarg ].

relative-clause := clause & 
  [ SYNSEM.LOCAL.CAT [ MC na,
                       POSTHEAD +,
                       HEAD verb &
                            [ MOD < [ LOCAL intersective-mod & 
                                            [ CAT.VAL [ SUBJ < >,
                                                        COMPS < > ] ] ] > ] ] ]
"""
; The immediate subtypes of clause are now relative-clause and non_rel_clause. 
; The latter groups together decl, imp, and (wh_)interrog, which are similar in 
; that they can't serve as modifiers and have empty REL values.
""".
  
non-rel-phrase := head-nexus-rel-phrase & 
  [ SYNSEM [ LOCAL.CONT.HOOK [ LTOP #ltop,
                               INDEX #ind ],
             NON-LOCAL.REL 0-dlist ],
    HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX #ind,
                      NON-LOCAL.REL 0-dlist ],
    C-CONT.HOOK [ LTOP #ltop,
                  INDEX #ind ] ].

basic-non-rel-clause := non-rel-phrase & clause.

non-rel-clause := basic-non-rel-clause.

declarative-clause := non-rel-clause &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

imperative-clause := non-rel-clause &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF comm ].

interrogative-clause := clause & basic-headed-phrase &
  [ SYNSEM [ LOCAL.CONT.HOOK [ LTOP #ltop,
                               INDEX #ind & [ SF prop-or-ques ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         REL 0-dlist ] ],
    HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX #ind,
                      NON-LOCAL.REL 0-dlist ],
    C-CONT.HOOK [ LTOP #ltop,
                  INDEX #ind ] ].


; --- head-punct-phrase types

basic-head-punct-phrase := head-valence-phrase & head-compositional &
  [ SYNSEM [ SLSHD #slshd,
             LOCAL [ COORD #coord,
                     COORD-STRAT #coord-strat,
                     COORD-REL #crel,
                     CAT #cat,
                     CONT #cont ] ],
    HEAD-DTR.SYNSEM [ SLSHD #slshd,
                      LOCAL [ COORD #coord,
                              COORD-STRAT #coord-strat,
                              COORD-REL #crel,
                              STR.HEADED solely,
                              CAT #cat,
                              CONT #cont ] ] ].

punct-head_clt_phrase := phrase-or-lexrule &
  [ SYNSEM [ SLSHD #slshd,
             PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct ],
             LOCAL [ COORD #coord,
                     COORD-STRAT #coord-strat,
                     COORD-REL #crel,
                     CAT #cat,
                     CONT #cont & 
                          [ HOOK #hook,
                            RELS #rels,
                            HCONS #hcons ] ],
             NON-LOCAL #non-local ],
    C-CONT [ HOOK #hook,
             RELS #rels,
             HCONS #hcons ],
    ARGS < [ SYNSEM punct_synsem & 
                    [ LOCAL.CAT.HEAD.PUNCT-MK #lpunct & lpunct ] ], 
           [ SYNSEM clitic-synsem & 
                    [ SLSHD #slshd,
                      PUNCT.RPUNCT #rpunct,
                      LOCAL [ STR.HEADING right,
                              COORD #coord,
                              COORD-STRAT #coord-strat,
                              COORD-REL #crel,
                              STR.HEADED solely,
                              CAT #cat,
                              CONT #cont ],
                      NON-LOCAL #non-local ] ] > ].


punct-head_phrase := basic-head-punct-phrase & basic-binary-phrase &
  [ SYNSEM [ LIGHT +,
             LOCAL.STR.HEADED right,
             PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct ] ],
    NON-HEAD-DTR #non-head & 
                 [ SYNSEM punct_synsem & 
                          [ LOCAL.CAT.HEAD.PUNCT-MK #lpunct & lpunct ] ],
    HEAD-DTR #head & 
             [ SYNSEM [ LIGHT +,
                        PUNCT.RPUNCT #rpunct,
                        LOCAL.STR.HEADING right ] ],
    ARGS < #non-head, #head > ].


head-punct_phrase := basic-head-punct-phrase & basic-binary-phrase &
  [ SYNSEM [ LIGHT +,
             LOCAL.STR.HEADED left,
             PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct ] ],
    HEAD-DTR #head & 
             [ SYNSEM [ LIGHT +,
                        PUNCT.LPUNCT #lpunct & no_punct,
                        LOCAL.STR.HEADING left ] ],
    NON-HEAD-DTR #non-head & 
                 [ SYNSEM punct_synsem & 
                          [ LOCAL.CAT.HEAD.PUNCT-MK #rpunct & rpunct ] ],
    ARGS < #head, #non-head > ].
    
head-punct_ind_phrase := head-punct_phrase & 
[ SYNSEM.LOCAL.AGR #agr,
  HEAD-DTR.SYNSEM.LOCAL [ AGR #agr,
                          CONT.HOOK.INDEX ref-ind ] ].

punct-head_ind_phrase := punct-head_phrase & 
[ SYNSEM.LOCAL.AGR #agr,
  HEAD-DTR.SYNSEM.LOCAL [ AGR #agr,
                          CONT.HOOK.INDEX ref-ind ] ].

head-punct_ev_phrase := head-punct_phrase & 
[ SYNSEM.LOCAL.AGR #agr,
  HEAD-DTR.SYNSEM.LOCAL [ AGR #agr,
                          CONT.HOOK.INDEX event ] ].

punct-head_ev_phrase := punct-head_phrase & 
[ SYNSEM.LOCAL.AGR #agr,
  HEAD-DTR.SYNSEM.LOCAL [ AGR #agr,
                          CONT.HOOK.INDEX event ] ].

; --- head-subj-phrase types

basic-head-subj-phrase := head-valence-phrase & head-compositional & binary-headed-phrase &
  [ SYNSEM [ SLSHD #slshd,
             LOCAL.CAT [ MC #mc,
                       VAL [ COMPS #comps,
                             SPR #spr,
                             SPEC #spec,
                             CLTS #clit ] ] ],
    HEAD-DTR.SYNSEM [ SLSHD #slshd,
                      LOCAL [ COORD -,
                            CAT [ MC #mc,
                                  HEAD.KEYS.KEY v_event_rel, 
                                  VAL [ COMPS #comps,       
                                        SPR #spr,
                                        SPEC #spec,
                                        CLTS #clit & < > ] ] ] ],
    NON-HEAD-DTR.SYNSEM canonical-synsem &
                        [ LOCAL.CAT.HEAD [ PRD non-prd ],
                          NON-LOCAL.REL 0-dlist ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

norm-basic-head-subj-phrase := basic-head-subj-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #synsem >,
    NON-HEAD-DTR.SYNSEM #synsem ].


subj-head-phrase := norm-basic-head-subj-phrase & head-final & 
  [ SYNSEM.LOCAL.CAT [ POSTHEAD +,
                       VAL.COMPS < > ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & 
                                     [ INV -, 
                                       VFORM fin ],
                                VAL.COMPS olist ] ]
"""
; In languages which do realize all COMPS before the SUBJ, head-subj-phrase should allow [COMPS olist]
""".

subj-head_nonque_phrase := subj-head-phrase &
  [ HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist ].

head-subj_phrase := norm-basic-head-subj-phrase & head-initial & 
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD verb & 
                                     [ VFORM fin,
                                       TAM.MOOD ind_or_sub_mood ],
                      NON-LOCAL [ QUE 0-dlist,
                                  SLASH 0-dlist ] ], 
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist ]
"""
; VOS, VPS, VOPS (el sujeto es foco)
; VSOP (admite una interpretación de foco amplio
""".

head-subj_rel_phrase := norm-basic-head-subj-phrase & head-initial & 
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD [ VFORM fin,
                                       VOICE active,
                                       TAM.MOOD ind_or_sub_mood ],
                      NON-LOCAL [ SLASH 1-dlist,
                                  QUE 0-dlist ] ],  
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist ]
"""
; for inverted subjects in relative and interrogative clauses
""".  

head-subj_imperative_phrase := norm-basic-head-subj-phrase & head-initial & 
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD [ VFORM fin,
                                       TAM.MOOD imp ],
                      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist ] ],  
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist ]
"""
; for inverted subjects in imperative (e.g. vengan ustedes)
""".  

head-subj_cpa_phrase := norm-basic-head-subj-phrase & head-initial & 
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verb & 
                                       [ AUX -,
;                                        INV +, 
                                         VFORM part,
                                         VOICE passive,
                                         TAM.MOOD ind_or_sub_mood ] ],
;                                 VAL.COMPS < [ ] > ],
                      NON-LOCAL [ QUE 0-dlist,
                                  SLASH 0-dlist ] ],  
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist ]
"""
; for inverted subjects in CPA constructions (e.g. muerto el perro, se acabó la rabia)
""".  

head-subj_vpinf_phrase := norm-basic-head-subj-phrase & head-initial & 
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD.VFORM inf,
                      NON-LOCAL [ QUE 0-dlist,
                                  SLASH 0-dlist ] ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist ]
"""
; for inverted subjects in VPinf (e.g. empezó tras irrumpir los manifestantes)
""".  

head-subj_coord_phrase := basic-head-subj-phrase & head-initial & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < >,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verb & [ TAM.MOOD ind_or_sub_mood ],
                                  VAL.SUBJ < [ LOCAL [ CAT #cat,
                                                       CONT [ HOOK [ LTOP #ltop,
                                                                     XARG #xarg ],
                                                              RELS #rels,
                                                              HCONS #hcons ] ],
                                               NON-LOCAL #nlocal ] > ],
                      NON-LOCAL.QUE 0-dlist ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ COORD -,
                                  COORD-STRAT one,
                                  CAT #cat,
                                  CONT [ HOOK [ LTOP #ltop,
                                                XARG #xarg ],
                                         RELS #rels,
                                         HCONS #hcons ] ],
                          NON-LOCAL #nlocal & [ QUE 0-dlist ] ] ]
"""
; for inverted coordinated subject - mostly, coordinated subjects are in plural, but 
; there may be partial agreement with one of the subjects when the verb precedes the 
; subject and when the subject denotes an abstract entity 
; (e.g. en la corte existía/existían el favoritismo y la corrupción).
""".  


; --- head-comp-phrase types

basic-head-comp-or-marker-phrase := head-valence-phrase & head-compositional & binary-headed-phrase &
  [ SYNSEM canonical-synsem &
           [ LOCAL.CAT [ MC #mc,
                         VAL [ SUBJ #subj,
                               SPR #spr,
                               SPEC #spec,
                               CLTS #clts ] ],
             MODIFIED #modif ],
    HEAD-DTR.SYNSEM [ LOCAL [ COORD -,
                              CAT [ HEAD +nvjrpc, 
                                    MC #mc,
                                    VAL [ SUBJ #subj,
                                          SPR #spr,
                                          SPEC #spec,
                                          CLTS #clts ] ] ],
                      MODIFIED #modif ],
    NON-HEAD-DTR.SYNSEM canonical-synsem ].

head-marker_phrase := basic-head-comp-or-marker-phrase & head-initial &
  [ SYNSEM [ SLSHD #slshd,
             LOCAL [ STR.HEADING no,
                     CAT [ HEAD.PRD #prd,
                     HC-LIGHT #hclight,
                           VAL.COMPS #comps & < > ] ], 
	     NON-LOCAL #nonlocal,
	     LIGHT - ],
;	     LIGHT #light ],
    HEAD-DTR.SYNSEM [ SLSHD #slshd,
                      LOCAL.CAT [ HEAD adp & [ KEYS.KEY selected_rel ],
                                  VAL.COMPS < #synsem . #comps > ] ],
    NON-HEAD-DTR.SYNSEM canonical-synsem & #synsem & 
                        [ LOCAL.CAT [ HC-LIGHT #hclight,
                                      HEAD.PRD #prd ],
                          NON-LOCAL #nonlocal ],
;                          LIGHT #light ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

basic-head-comp-phrase := basic-head-comp-or-marker-phrase & 
  [ SYNSEM [ LOCAL.CAT [ POSTHEAD #ph,
                         VAL.COMPS #comps ],
             LIGHT - ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD #ph,
                                HEAD.KEYS.KEY independent_rel,
                                VAL.COMPS < #synsem . #comps > ],
    NON-HEAD-DTR.SYNSEM canonical-synsem & #synsem,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

head-comp_second_phrase := basic-head-comp-or-marker-phrase & head-initial &
  [ SYNSEM [ LIGHT -,
             SLSHD #slshd,
             LOCAL.CAT [ POSTHEAD #ph,
                         VAL.COMPS < #comp1 > ] ],
    HEAD-DTR.SYNSEM [ SLSHD #slshd,
                      LOCAL.CAT [ POSTHEAD #ph,
                                  HEAD verb & [ KEYS.KEY independent_rel ],
                                  VAL.COMPS < #comp1 & [ ], #synsem > ] ],
    NON-HEAD-DTR.SYNSEM canonical-synsem & #synsem & [ LOCAL.CAT.MC na ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

comp-head_phrase := basic-head-comp-phrase & head-final & 
  [ SYNSEM.LOCAL.STR.HEADING right_or_no,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ INV + ] ].

head-comp-phrase := basic-head-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.STR.HEADED left ].

head-comp_x-xp_phrase := head-comp-phrase & 
  [ SYNSEM.SLSHD #slshd,
    HEAD-DTR.SYNSEM.SLSHD #slshd,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.MC na ].

head-comp_x-cl_phrase := head-comp-phrase & 
  [ SYNSEM.SLSHD #slshd,
    HEAD-DTR.SYNSEM [ SLSHD #slshd,
                      LOCAL.CAT.MC na ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ MC bool,
                                      HEAD +vpc ],
                                CONT.HOOK.INDEX event &
                                                [ SF prop-or-ques ] ] ].

head-comp_v-cl_phrase := head-comp-phrase & 
  [ SYNSEM.SLSHD #slshd,
    HEAD-DTR.SYNSEM [ SLSHD #slshd,
                      LOCAL.CAT [ MC bool,
                                  HEAD +vpc ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ MC bool,
                                        HEAD +vpc ],
                                  CONT.HOOK.INDEX event & 
                                                  [ SF prop-or-ques ] ],
                          NON-LOCAL.SLASH 0-dlist ] ].

head-comp_v-cl-slash_phrase := head-comp-phrase & 
  [ SYNSEM.SLSHD +, 
    HEAD-DTR.SYNSEM.LOCAL.CAT [ MC bool,
                                HEAD +vpc & 
                                     [ INV - ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ MC bool,
                                        HEAD +vpc & [ VOICE active ] ],
                                  CONT.HOOK.INDEX event &
                                                  [ SF prop-or-ques ] ],
                          NON-LOCAL.SLASH 1-dlist ] ].


head-comp_aux-vp_phrase := head-comp-phrase & 
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.AUX +,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb ].


; --- head-clitic-phrase types

clit-head_phrase_basic := head-valence-phrase & head-compositional & head-final & 
  [ SYNSEM [ LIGHT -,
             MODIFIED #modif,
             SLSHD #slshd,
             LOCAL [ CAT [ MC #mc,
                           VAL [ SUBJ #subj,
                                 SPR #spr,
                                 COMPS #comps,
                                 SPEC #spec,
                                 CLTS #clts ] ] ] ],
    HEAD-DTR.SYNSEM [ MODIFIED #modif,
                      SLSHD #slshd,
                      LOCAL.CAT [ MC #mc,
                                  HEAD verb & [ TAM.MOOD ind_or_sub_mood ], 
                                  VAL [ SUBJ #subj,
                                        SPR #spr,
                                        SPEC #spec,
                                        COMPS #comps,
                                        CLTS < #synsem . #clts > ] ] ],
    NON-HEAD-DTR.SYNSEM #synsem & clitic-synsem & 
                        [ LOCAL.CONT.HOOK.INDEX ref-ind ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

clit-head_phrase := clit-head_phrase_basic & 
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

;sbct-hd_constr := subj-clit-head_phrase & binary-rule-left-to-right. ; ***.

;subj-clit-head_phrase := clit-head_phrase_basic & 
;  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < > ],
;    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #ind ] >,
;                                    COMPS < > ],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #ind ].



clit-head_phrase_cl := clit-head_phrase_basic & 
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < > ].

; --- head-spec-phrase types

basic-head-spec-phrase := head-valence-phrase & phrasal & very-basic-binary-phrase & 
  [ INFLECTED +,
    SYNSEM [ SLSHD #slshd,
             LOCAL [ COORD -,
                     COORD-STRAT #coord-strat,
                     AGR #agr,
                     CAT [ MC #mc,
                           POSTHEAD #hdph,
                           VAL [ SUBJ #subj,
                                 COMPS #spcomps,
                                 SPEC #spec,
                                 CLTS #clit ] ],
                     CONT.HOOK.INDEX #index ],
             MODIFIED #modif ],
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ SLSHD #slshd,
                        LOCAL [ AGR #agr,
                                COORD -,
                                COORD-STRAT #coord-strat,
                                CAT [ MC #mc,
                                      POSTHEAD #hdph,
                                      VAL [ SUBJ #subj,
                                            COMPS #comps & < >,
                                            SPEC #spec,
                                            CLTS #clit & < > ] ],
                                CONT.HOOK #hdhook & [ INDEX #index ] ],
                        MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ COORD -,
                                  CAT [ VAL [ SPEC < [ LOCAL [ AGR #agr,
                                                               CAT.VAL.COMPS #comps,
                                                               CONT.HOOK #hdhook ],
                                                       MODIFIED #hmodif ] >,
                                              COMPS #spcomps ] ] ],
                          MODIFIED #modif ],
    C-CONT [ RELS  <! !>,
             HCONS <! !> ] ]
"""
; agreement features are percolated from HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX 
; where NUMBER is not checked in 'ad sensum agreement'
""".

norm-basic-head-spec-phrase := basic-head-spec-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD [ MOD #mod,
                            PRD #prd,
                            TAM #tam,
                            KEYS.KEY #key ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD [ MOD #mod,
                                       PRD #prd,
                                       TAM #tam,
                                       KEYS.KEY #key ],
                                VAL.SPR < #synsem > ],
    NON-HEAD-DTR.SYNSEM #synsem ].

norm_spec-head-phrase := norm-basic-head-spec-phrase & 
  [ SYNSEM.LOCAL.STR.HEADED right,
    NON-HEAD-DTR #non-head-dtr &
                 [ SYNSEM [ PUNCT.RPUNCT no_punct,
                            LOCAL.CAT.POSTHEAD - ] ],
    HEAD-DTR #head-dtr & [ SYNSEM.LOCAL.STR.HEADING right ],
    ARGS < #non-head-dtr, #head-dtr > ].


; for specifiers following nouns
head-spec_phrase := norm-basic-head-spec-phrase & binary-headed-phrase & 
  [ SYNSEM.LOCAL [ STR [ HEADING right_or_no,
                         HEADED left ],
                   CAT [ HEAD #head & [ KEYS #keys ],
                         VAL.SPR #spr ] ],
    NON-HEAD-DTR #non-head-dtr & 
                 [ SYNSEM #synsem & 
                          [ LOCAL [ CAT [ POSTHEAD +,
                                          HEAD det,
                                          VAL.SPEC < [ LOCAL.CAT.HEAD #head ] > ],
                                    CONT.HOOK #hook ] ] ],
    HEAD-DTR #head-dtr & 
             [ SYNSEM [ LOCAL [ STR.HEADING left, 
                                CAT [ HEAD noun & [ KEYS #keys ],
                                      VAL [ SPR < #synsem . #spr >,
                                            COMPS < > ] ] ],
                        NON-LOCAL.REL 0-dlist ] ],
    ARGS < #head-dtr, #non-head-dtr >,
    C-CONT.HOOK #hook ]
"""
; for specifiers following nouns
""".

spec-head_phrase := norm_spec-head-phrase & binary-headed-phrase & 
  [ SYNSEM.LOCAL [ CAT [ HEAD #head & 
                              [ CASE #case, 
                                KEYS #keys ],
                         VAL.SPR #spr ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ HEAD #head &
                                         [ CASE #case, 
                                           KEYS #keys ],
                                    VAL [ SPR < #synsem . #spr >,
                                          COMPS < > ] ] ],
                      NON-LOCAL.REL 0-dlist ],
    NON-HEAD-DTR.SYNSEM #synsem & 
                        [ LOCAL [ CAT [ HEAD det & [ KEYS.KEY quant_or_wh_rel ],
                                        VAL.SPEC < [ LOCAL.CAT.HEAD #head ] > ],
                                  CONT.HOOK #hook ] ],
    C-CONT.HOOK #hook ]
"""
; for specifiers of nouns
""".


spec-head_hdrel_phrase := norm_spec-head-phrase & explt-binary-phrase & 
  [ INFLECTED +,
    SYNSEM [ PUNCT [ LPUNCT #lpunct,
                     RPUNCT #rpunct ],
             LOCAL [ STR.HEADING right_or_no,
                     CAT [ HEAD #head & [ CASE #case, KEYS #keys ],
                           VAL.SPR #spr ] ] ],
    HEAD-DTR [ INFLECTED +,
               SYNSEM [ PUNCT.LPUNCT #lpunct,
                        LOCAL [ CAT [ HEAD noun & [ CASE #case, 
                                                    KEYS #keys  & [ KEY que_pron_rel ] ],
                                      VAL [ SPR < #synsem . #spr >,
                                            COMPS < > ] ] ],
                        NON-LOCAL.REL 1-dlist ] ],
    NON-HEAD-DTR [ INFLECTED +,
                   SYNSEM #synsem & 
                          [ PUNCT.RPUNCT #rpunct,
                            LOCAL [ CAT [ HEAD det,
                                          VAL.SPEC < [ LOCAL.CAT.HEAD #head ] > ],
                                    CONT.HOOK #hook ],
                            NON-LOCAL.REL 0-dlist ] ],
    C-CONT.HOOK #hook ]
"""
; for specifiers of relative pronouns
""".

spec-head_hddet_phrase := norm_spec-head-phrase & head-final & head-compositional & 
  [ SYNSEM.LOCAL [ STR.HEADING right_or_no,
                   CAT [ HEAD #head & [ KEYS #keys ],
                         VAL.SPR #spr ] ],
    HEAD-DTR.SYNSEM.LOCAL [ AGR #agr,
                            CAT [ HEAD det & [ KEYS #keys ],
                                  VAL [ SPR < [ LOCAL.AGR #agr ] >,
                                        COMPS < > ] ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD det,
                                    VAL [ SPEC < [ LOCAL.CAT.HEAD #head ] >,
                                          SPR #spr ] ] ]
"""
; for specifiers of determiners (e.g. todos los, casi todos los, sólo los,...) 
""".

spec-head_specrel_phrase := norm_spec-head-phrase & binary-headed-phrase & 
  [ SYNSEM.LOCAL [ STR.HEADING right_or_no,
                   CAT [ HEAD [ CASE #case, 
                                KEYS [ KEY #key, 
                                       ALTKEY proper_expl_q_rel ] ],
                         VAL.SPR #spr ] ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD noun & 
                                       [ CASE #case, 
                                         KEYS.KEY #key ],
                                  VAL [ SPR < #synsem . #spr >,
                                        COMPS < > ] ],
                      NON-LOCAL.REL 1-dlist ],
    NON-HEAD-DTR.SYNSEM #synsem & 
                        [ LOCAL [ CAT [ HEAD det ],
                                  CONT.HOOK #hook ],
                          NON-LOCAL.REL 1-dlist ],
    C-CONT.HOOK #hook ]
"""
; for "cuyo"
""".

spec-head_specdeg_phrase := norm_spec-head-phrase & head-final & head-compositional & 
  [ SYNSEM.LOCAL.CAT [ HEAD #head & [ KEYS #keys ],
                       VAL.SPR #spr ],
    HEAD-DTR.SYNSEM.LOCAL [ COORD -,
                            CAT.HEAD.KEYS #keys ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD.KEYS.KEY degree_rel,
                                    VAL [ SPEC < [ LOCAL.CAT.HEAD #head ] >,
                                          SPR #spr ] ],
                          NON-LOCAL.QUE <! !>  ] ]
"""
; for degree specifiers
""".


; --- head-mod-phrase types

head-mod-phrase := head-nexus-phrase &
  [ SYNSEM [ MODIFIED hasmod,
             SLSHD #slshd,
             LOCAL.CAT [ MC #mc,
                         VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPEC #spec,
                               CLTS #clit ] ] ],
    HEAD-DTR.SYNSEM [ SLSHD #slshd,
                      LOCAL.CAT [ MC #mc,
                                  VAL [ SUBJ #subj,
                                        COMPS #comps,
                                        SPEC #spec,
                                        CLTS #clit ] ] ] ].

basic-head-mod-phrase-simple := head-mod-phrase & binary-headed-phrase &
  [ SYNSEM [ LOCAL.CAT.MC #mc,
             NON-LOCAL.SLASH [ LIST #first,
                               LAST #last ] ],
    HEAD-DTR.SYNSEM #synsem & 
                    [ LOCAL.CAT.MC #mc,
                      NON-LOCAL.SLASH [ LIST #middle,
                                        LAST #last ] ],
    NON-HEAD-DTR.SYNSEM 
           [ LOCAL [ COORD -,
                     CAT [ HEAD.MOD < #synsem >,
                           VAL [ COMPS < >,
                                 CLTS < > ] ] ],
             NON-LOCAL [ SLASH [ LIST #first,
                                 LAST #middle ],
                         QUE 0-dlist & [ LIST null ] ] ],
    C-CONT.RELS <! !> ].

head-mod-phrase-simple := basic-head-mod-phrase-simple &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #htop,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.LTOP #htop ] > ].

adj-head-phrase := basic-head-mod-phrase-simple & head-final &
  [ SYNSEM [ LIGHT -,
             MODIFIED lmod & [ PERIPH #periph ],
             LOCAL.CAT [ POSTHEAD #ph,
                         VAL.SPR #spr,
                         HEAD.PRD.HABER #haber ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD #ph,
                                VAL [ SPR #spr,
                                      CLTS < > ] ],
    NON-HEAD-DTR.SYNSEM [ MODIFIED.PERIPH #periph,
                          LOCAL.CAT [ HEAD.PRD.HABER #haber,
                                      VAL.COMPS < > ],
                          NON-LOCAL [ SLASH 0-dlist,
                                      REL 0-dlist ] ] ].

basic-head-adj-phrase := basic-head-mod-phrase-simple & phrasal &
  [ SYNSEM.MODIFIED rmod & [ PERIPH #periph ],
    HEAD-DTR.SYNSEM.MODIFIED.PERIPH #periph,
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist ].

head-adj-phrase := basic-head-adj-phrase & head-initial.
non_str-head-adj-phrase := basic-head-adj-phrase & non_str-head-initial.

; We split head-adj-phrase and adj-head-phrase into two each, one for intersective 
; modifiers and one for scopal modifiers, in order to get desired results for recursive 
; modification as in "apparently difficult problem" (cf. Kasper '98). This split is also 
; used in generation, where we delay construction of intersective modification, but not scopal.
; scopal-mod-phrase := head-mod-phrase-simple &
; [ NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal-mod &
;                                                      [ CONT.HOOK.XARG #xarg ] ] >,
;                               CONT.HOOK #hook & [ XARG #xarg ] ],
;   C-CONT [ HOOK #hook,
;            HCONS <! !> ] ].

scopal-mod-phrase := head-mod-phrase-simple &
  [ NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL scopal-mod ] >,
                                CONT.HOOK #hook  ],
    C-CONT [ HOOK #hook,
             HCONS <! !> ] ].

isect-mod-phrase := head-mod-phrase-simple & head-compositional &
  [ HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #hand,
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective-mod ] >,
                                CONT.HOOK.LTOP #hand ],
    C-CONT.HCONS <! !> ].

adj-head_scop_phrase := adj-head-phrase & scopal-mod-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD.HABER #haber,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ POSTHEAD -,
                                      HEAD +jrp & [ PRD.HABER #haber ] ] ] ]
"""
; scopal adjunct + head
""".
                                    
adj-head_int-xp-xp_phrase :=  adj-head-phrase & isect-mod-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRD #prd,
                            MOD < [ LOCAL [ AGR #agr,
                                            CONT.HOOK.INDEX #ind ] ] > ],
    HEAD-DTR.SYNSEM [ LOCAL [ AGR #agr,
                              CONT.HOOK.INDEX #ind,
                              CAT [ HEAD +jrp,
                                    VAL.COMPS < > ] ],
                      NON-LOCAL.REL 0-dlist ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ AGR #agr,
                                CAT [ POSTHEAD -,
                                      HEAD.PRD #prd ] ] ]
"""
; intersective adjunct + head
""".

adj-head_int-xp-n_phrase :=  adj-head-phrase & isect-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD noun,
                                  VAL [ COMPS < >,
                                        SPR #spr & < [ ] > ] ],
                      NON-LOCAL [ SLASH 0-dlist,
                                      QUE 0-dlist & [ LIST < > ],
                                      REL 0-dlist & [ LIST < > ] ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD - ].

adj-head_int-adv-s_phrase := adj-head-phrase & isect-mod-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb,
                                VAL.COMPS < > ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD adv & [ KEYS.KEY adv_rel ],
                                    POSTHEAD - ] ].

adj-head_int-vp-vp_phrase := adj-head-phrase & isect-mod-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verb & [ VFORM fin ],
                                  VAL.COMPS < > ] ],
;                      NON-LOCAL.SLASH <! [ ] !> ], 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ VFORM ger ] ].

adj-head_int-adv-vp_phrase := adj-head-phrase & isect-mod-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verb,
                                  VAL.COMPS < > ] ],
;                     NON-LOCAL.SLASH <! [ ] !> ], 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD adv & [ KEYS.KEY adv_rel ],
                                    POSTHEAD + ] ].

adj-head_int-modnp-vp_phrase := adj-head-phrase & isect-mod-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verb,
                                  VAL.COMPS < > ] ],
;                     NON-LOCAL.SLASH <! [ ] !> ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD modnp & [ KEYS.KEY prep_mod_rel ] ] ].

adj-head_int-pp-vp_phrase := adj-head-phrase & isect-mod-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verb & [ VFORM fin ],
                                  VAL [ COMPS < > ] ] ],
;                     NON-LOCAL.SLASH <! [ ] !> ], 
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD adp & [ KEYS.ALT2KEY non_free_relative_q_rel ],
                                    POSTHEAD - ] ].

head-adj_scop-xp-cl_phrase := head-adj-phrase & scopal-mod-phrase & 
  [ SYNSEM.LOCAL.CAT [ POSTHEAD #ph, 
                       VAL.SPR #spr ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD #ph, 
                                VAL.SPR #spr ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ POSTHEAD +,
                                        MC bool,
                                        HEAD adp ],
                                  CONT.HOOK.INDEX event & 
                                                  [ SF prop-or-ques ] ],
                          NON-LOCAL.REL 0-dlist ] ]
"""
; head + scopal adjunct
""".

head-adj_scop-xp-xp_phrase := head-adj-phrase & scopal-mod-phrase & 
  [ SYNSEM.LOCAL.CAT [ POSTHEAD #ph, 
                       VAL.SPR #spr ],
    HEAD-DTR.SYNSEM [ MODIFIED notmod-or-rmod,
                      LOCAL.CAT [ POSTHEAD #ph, 
                                  VAL.SPR #spr ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ POSTHEAD +,
;                                     MC na, 
;                                     HEAD +njrp ],
                                      HEAD +jr ],
                          NON-LOCAL [ SLASH 0-dlist,
                                      REL 0-dlist ] ] ].

head-adj_int-ap-xp_phrase := head-adj-phrase & isect-mod-phrase &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD #ph, 
                       VAL.SPR #spr ],
    HEAD-DTR.SYNSEM [ MODIFIED notmod-or-rmod,
                      LOCAL.CAT [ POSTHEAD #ph, 
                                  HEAD adj,
                                  VAL.SPR #spr ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD +,
                          NON-LOCAL [ SLASH 0-dlist,
                                      REL 0-dlist & [ LIST < > ] ] ] ]
"""
; head + intersective adjunct
""".

head-adj_int-pp-xp_phrase := head-adj-phrase & isect-mod-phrase &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD #ph, 
                       VAL.SPR #spr ],
    HEAD-DTR.SYNSEM [ MODIFIED notmod-or-rmod,
                      LOCAL.CAT [ POSTHEAD #ph, 
                                  HEAD adp & 
                                       [ MOD < [ LOCAL intersective-mod ] > ],
                                  VAL.SPR #spr ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD + ].

head-adj-int-v-xp-phrase := head-adj-phrase & isect-mod-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD verb,
                                  VAL.SPR #spr ],
                      NON-LOCAL.REL 0-dlist ],
;   NON-HEAD-DTR.SYNSEM [ LOCAl.CAT.POSTHEAD +, 
    NON-HEAD-DTR.SYNSEM.NON-LOCAL [ SLASH 0-dlist,
                                    REL 0-dlist & [ LIST < > ] ] ]
"""
; verbal head + intersective adjuncts
""".

head-adj_int-s-xp_phrase := head-adj-int-v-xp-phrase &
  [ SYNSEM.LOCAL.CAT.POSTHEAD #ph,
    HEAD-DTR.SYNSEM [ PUNCT.RPUNCT comma_punct,
                      LOCAL.CAT [ POSTHEAD #ph, 
                                  VAL [ SUBJ < >, 
                                        COMPS < > ] ] ],
    NON-HEAD-DTR.SYNSEM.LOCAl.CAT.HEAD adp ]
"""
; también le pidió un papel, como Harrison Ford
""".

head-adj_int-v-pp_phrase := head-adj-int-v-xp-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD -,
                      MODIFIED notmod-or-rmod ],
    NON-HEAD-DTR.SYNSEM.LOCAl.CAT.HEAD adp ].

head-adj_int-v-adv_phrase := head-adj-int-v-xp-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD -,
                      MODIFIED notmod-or-rmod ],
    NON-HEAD-DTR.SYNSEM.LOCAl.CAT.HEAD adv & [ KEYS.KEY basic_adv_rel ] ].

head-adj_int-v-modnp_phrase := head-adj-int-v-xp-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD -,
                      MODIFIED notmod-or-rmod ],
    NON-HEAD-DTR.SYNSEM.LOCAl.CAT.HEAD modnp & [ KEYS.KEY prep_mod_rel ] ].

head-adj_int-v-vger_phrase := head-adj-int-v-xp-phrase &
  [ SYNSEM.LOCAL.CAT.POSTHEAD #ph,
    HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD #ph,
                      MODIFIED notmod-or-rmod ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ VFORM ger ] ].

head-adj_int-v-frel_phrase := head-adj-int-v-xp-phrase &
  [ HEAD-DTR.SYNSEM [ MODIFIED notmod-or-rmod,
                      LOCAL.CAT.POSTHEAD - ],
    HEAD-DTR.SYNSEM.PUNCT.RPUNCT no_punct,
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD modnp & [ KEYS.KEY prep_mod_rel ],
                                CONT.RELS.LIST.REST.FIRST.PRED free_relative_q_rel ] ]
"""
; for free RC, which can't be separated from the head-dtr with a comma
""".

head-adj-int-n-xp-phrase := head-adj-phrase & isect-mod-phrase &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD #ph, 
                       LASTNMOD - ],
    HEAD-DTR.SYNSEM [ MODIFIED notmod-or-rmod,
                      LOCAL.CAT [ POSTHEAD #ph, 
                                  LASTNMOD -,
                                  HEAD noun ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.POSTHEAD +,
                          NON-LOCAL [ SLASH 0-dlist,
                                      QUE 0-dlist & [ LIST < > ],
                                      REL 0-dlist & [ LIST < > ] ] ] ]
"""
; nominal head + intersective adjuncts
""".

head-adj_int-cn-ap_phrase := head-adj-int-n-xp-phrase &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR #spr,
                   AGR #agr,
                   CONT.HOOK.INDEX #ind ],
    HEAD-DTR.SYNSEM [ PUNCT.RPUNCT no_punct,
                      LOCAL [ AGR #agr,
                              CAT [ HEAD.KEYS.KEY all_common_nom_rel,
                                    VAL.SPR #spr & < [ ] > ],
                              CONT.HOOK.INDEX #ind & [ PRONTYPE not_pron ] ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj ]
"""
; common nouns
""".

head-adj_int-cn-pp_phrase := head-adj-int-n-xp-phrase &
  [ SYNSEM.LOCAL [ CAT.VAL.SPR #spr,
                   AGR #agr ],
    HEAD-DTR.SYNSEM [ PUNCT.RPUNCT no_punct,
                      LOCAL [ AGR #agr,
                              CAT [ HEAD.KEYS.KEY all_common_nom_rel,
                                    VAL.SPR #spr & < [ ] > ],
                              CONT.HOOK.INDEX.PRONTYPE not_pron ] ],
;    NON-HEAD-DTR.SYNSEM.LOCAl [ CAT.HEAD prep_or_modnp,
    NON-HEAD-DTR.SYNSEM.LOCAl [ CAT.HEAD adp,
                                CONT.RELS.LIST < prep-relation, ... > ] ].

head-adj_int-cn-vger_phrase := head-adj-int-n-xp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM [ PUNCT.RPUNCT no_punct,
                      LOCAL [ CAT [ HEAD.KEYS.KEY all_common_nom_rel,
                                    VAL.SPR #spr & < [ ] > ],
                              CONT.HOOK.INDEX.PRONTYPE not_pron ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD +, 
                                    HEAD verb & [ VFORM ger ] ] ].

head-adj_int-np-pp_phrase := head-adj-int-n-xp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM [ PUNCT.RPUNCT no_punct,
                      LOCAL [ COORD-STRAT zero,
                              CAT [ HEAD.KEYS.KEY all_common_nom_rel,
                                    VAL.SPR #spr & < > ],
                              CONT.HOOK.INDEX.PRONTYPE not_pron ] ],
    NON-HEAD-DTR.SYNSEM.LOCAl [ CAT.HEAD adp,
                                CONT.RELS.LIST < pp-relation, ... > ] ].

head-adj_int-np-xp-pct_phrase := head-adj-int-n-xp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM [ PUNCT.RPUNCT comma_punct,
                      LOCAL [ COORD-STRAT zero,
                              CAT [ HEAD.KEYS.KEY all_common_nom_rel,
                                    VAL.SPR #spr & < > ],
                              CONT.HOOK.INDEX.PRONTYPE not_pron ] ] ].

head-adj_int-np-xp-crd_phrase := head-adj-int-n-xp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM [ PUNCT.RPUNCT no_punct,
                      LOCAL [ COORD-STRAT one,
                              CAT [ HEAD.KEYS [ KEY all_common_nom_rel,
                                                ALTKEY explicit_q_rel ],
                                    VAL.SPR #spr & < > ],
                              CONT.HOOK.INDEX.PRONTYPE not_pron ] ] ].

head-adj_int-pname-xp_phrase := head-adj-int-n-xp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL #local,
                                 NON-LOCAL #nlocal ] >,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY named_rel,
                                  VAL.SPR < [ LOCAL #local,
                                              NON-LOCAL #nlocal ] > ],
                            CONT.HOOK.INDEX.PRONTYPE not_pron ] ]
"""
; proper names
""".

head-adj_int-pn-xp_phrase := head-adj_int-pname-xp_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT - ] >,
    HEAD-DTR.SYNSEM.PUNCT.RPUNCT no_punct ]
"""
; la Rocío del otro día
""".

head-adj_int-pn-xp-pt_phrase := head-adj_int-pname-xp_phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT + ] >,
    HEAD-DTR.SYNSEM.PUNCT.RPUNCT comma_punct ]
"""
; Andrea Hoffmann es originaria de Kassel, en el land de Hesse
""".

head-adj_int-pr-xp_phrase := head-adj-int-n-xp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM.LOCAL [ CAT.VAL.SPR #spr,
                            CONT.HOOK.INDEX.PRONTYPE real_pron ] ]
"""
; pronouns
""".

head-adj-int-n-rc-phrase := head-adj-phrase & isect-mod-phrase &
  [ SYNSEM.LOCAL [ AGR #agr,
                   CAT [ POSTHEAD #ph,
                       LASTNMOD + ] ],
    HEAD-DTR.SYNSEM [ MODIFIED notmod-or-rmod,
                      LOCAL [ AGR #agr,
                              CAT [ POSTHEAD #ph,
                                  HEAD noun,
                                  VAL.COMPS < > ] ],
                      NON-LOCAL [ SLASH 0-dlist,
                                  REL 0-dlist & [ LIST < > ] ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ POSTHEAD +, 
                                      HEAD verb & [  MOD < [ PUNCT.RPUNCT no_punct ] > ] ],
                          NON-LOCAL [ SLASH 0-dlist,
                                      QUE 0-dlist,
                                      REL 1-dlist ] ] ]
"""
; adjuncts co-ocurring at last positions
""".

head-adj_int-n-rc_phrase := head-adj-int-n-rc-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY all_common_nom_rel,
                                  VAL.SPR #spr & < [ ] > ],
                            CONT.HOOK.INDEX.PRONTYPE not_pron ] ].

head-adj_int-pn-rc_phrase := head-adj-int-n-rc-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT -,
                                 LOCAL #local,
                                 NON-LOCAL #nlocal ] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.KEYS.KEY named_rel,
                                VAL.SPR < [ LOCAL #local,
                                            NON-LOCAL #nlocal ] > ] ].

head-adj_int-pr-rc_phrase := head-adj-int-n-rc-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM.LOCAL [ CAT.VAL.SPR #spr,
                            CONT.HOOK.INDEX.PRONTYPE real_pron ] ].


head-adj-int-n-rcpp-phrase := head-mod-phrase & head-initial & head-compositional & phrasal &
  [ SYNSEM [ MODIFIED rmod & [ PERIPH #periph ],
             LOCAL.CAT [ LASTNMOD +, 
                         MC #mc, 
                         POSTHEAD #ph ],
             NON-LOCAL [ SLASH [ LIST #first,
                                 LAST #last ] ] ],
    HEAD-DTR.SYNSEM #synsem & 
                    [ MODIFIED notmod-or-rmod & 
                               [ PERIPH #periph ],
                      LOCAL [ CAT [ MC #mc,
                                    POSTHEAD #ph,
                                    HEAD noun,
                                    VAL.COMPS < > ],
                              CONT.HOOK.LTOP #hand ],
                      NON-LOCAL [ SLASH 0-dlist & [ LIST < > & #middle,
                                                    LAST #last],
                                  REL 0-dlist & [ LIST < > ] ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ POSTHEAD +,
                                        HEAD adp & [ MOD < #synsem & [ LOCAL intersective-mod ] > ],
                                        VAL.COMPS < > ],
                                  CONT.HOOK.LTOP #hand ],
                          NON-LOCAL [ SLASH 1-dlist & [ LIST #first,
                                                        LAST #middle ],
                                      QUE 0-dlist ] ],
    C-CONT.HCONS <! !> ].

head-adj_int-n-rcpp_phrase := head-adj-int-n-rcpp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.KEYS.KEY common_nom_rel,
                                VAL.SPR #spr ] ].

head-adj_int-pn-rcpp_phrase := head-adj-int-n-rcpp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT -,
                                 LOCAL #local,
                                 NON-LOCAL #nlocal ] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.KEYS.KEY named_rel,
                                VAL.SPR < [ LOCAL #local,
                                            NON-LOCAL #nlocal ] > ] ].

head-adj_int-pr-rcpp_phrase := head-adj-int-n-rcpp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    HEAD-DTR.SYNSEM.LOCAL [ CAT.VAL.SPR #spr,
                            CONT.HOOK.INDEX.PRONTYPE real_pron ] ].

head-adj_int-n-rcnr_phrase := non_str-head-adj-phrase & isect-mod-phrase & 
  [ SYNSEM.LOCAL.CAT [ POSTHEAD #ph,
                       LASTNMOD +,
                       VAL.SPR #spr ],
    HEAD-DTR.SYNSEM [ MODIFIED notmod-or-rmod,
                      LOCAL [ CAT [ POSTHEAD #ph,
                                    HEAD noun,
                                    VAL [ COMPS < >,
                                          SPR #spr & < > ] ] ],
                      NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                  REL 0-dlist & [ LIST < > ] ] ],
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT [ POSTHEAD +,
                                      HEAD verb ],
                          NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                      QUE 0-dlist,
                                      REL 1-dlist ] ] ]
"""
; non-restrictive RCs
""".

; apposition

basic-appos-phrase := head-nexus-phrase & head-compositional & basic-binary-phrase & 
  [ INFLECTED +,
    SYNSEM phr-synsem &
	   [ SLSHD #slshd,
             PUNCT.LPUNCT #lpunct,
	     LOCAL [ AGR.PNG #png,
                     CAT.VAL #valence ],
             NON-LOCAL.SLASH [ LIST #first,
                               LAST #last ] ],
    HEAD-DTR #head & 
          [ INFLECTED +,
            SYNSEM canonical-synsem &
	     [ PUNCT.LPUNCT #lpunct,
               SLSHD #slshd,
               LOCAL [ COORD -,
                       AGR.PNG #png,
                       CAT [ HEAD noun,
                             VAL #valence & [ COMPS < > ] ],
                       CONT.HOOK.INDEX #hind & ref-ind ],
               NON-LOCAL.SLASH [ LIST #middle,
                                 LAST #last ] ] ],
    NON-HEAD-DTR #non-head & 
          [ INFLECTED +,
            SYNSEM canonical-synsem &
  	     [ LOCAL [ COORD -,
                       CAT [ HEAD.PRD non-prd,
                             MC na,
                             VAL [ SUBJ < >,
                                   COMPS < > ] ],
                       CONT.HOOK.INDEX #modind ],
               NON-LOCAL [ SLASH [ LIST #first,
                                   LAST #middle ],
                           QUE 0-dlist ] ] ],
    ARGS < #head, #non-head >,
    C-CONT [ HCONS <! !>,
             RELS <! prep-relation &
                     [ PRED appos_rel,
                       ARG1 #hind,
                       ARG2 #modind ] !> ] ].

head-adj_int-bracket-appos_phrase := basic-appos-phrase &
  [ HEAD-DTR.SYNSEM [ PUNCT.RPUNCT no_punct,
                      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ],
    NON-HEAD-DTR.SYNSEM [ PUNCT [ LPUNCT bracket_op_punct,
                                  RPUNCT bracket_cl_punct ] ] ]
"""
; -- appositions between brackets
""".   

head-adj_int-cn-cn-appos_phrase := basic-appos-phrase &
  [ HEAD-DTR.SYNSEM [ PUNCT.RPUNCT comma_punct,
                      LOCAL [ CAT [ HEAD.KEYS.KEY common_nom_rel, 
                                    VAL.SPR < > ], 
                              CONT.HOOK.INDEX.SORT #sort ],
                      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun & 
                                           [ KEYS [ KEY non_modable_rel & common_nom_rel,
                                                    ALTKEY appos-able_rel ] ],
                                      VAL.SPR < > ],
                                CONT.HOOK.INDEX [ SORT #sort ] ] ].

head-adj_int-cn-cn-cln-appos_phrase := basic-appos-phrase &
  [ HEAD-DTR.SYNSEM [ PUNCT.RPUNCT cln_punct,
                      LOCAL [ CAT [ HEAD.KEYS.KEY non_modable_rel & common_nom_rel,
                                    VAL.SPR < > ], 
                              CONT.HOOK.INDEX.SORT #sort ],
                      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun & [ KEYS.KEY non_modable_rel & non_elliptical_n_rel ],
                                      VAL.SPR < > ],
                                CONT.HOOK.INDEX [ SORT #sort ] ] ].

head-adj_int-cn-pn-appos_phrase := basic-appos-phrase &
  [ SYNSEM.PUNCT.RPUNCT #rpunct,
    HEAD-DTR.SYNSEM [ LOCAL.CAT.VAL.SPR < >, 
                      NON-LOCAL.REL 0-dlist ],
    NON-HEAD-DTR.SYNSEM [ PUNCT.RPUNCT #rpunct,
                          LOCAL [ CAT [ HEAD noun & [ KEYS.KEY non_modable_rel & named_rel ],
                                        VAL.SPR < > ],
                                  CONT.HOOK.INDEX.PRONTYPE not_pron ] ] ].   

head-adj_int-pn-cn-appos_phrase := basic-appos-phrase &
  [ HEAD-DTR.SYNSEM [ PUNCT.RPUNCT comma_punct,
                      LOCAL [ CAT [ HEAD.KEYS.KEY named_rel,
                                    VAL.SPR < > ], 
                              CONT.HOOK.INDEX.SORT #sort ],
                      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD noun & [ KEYS.KEY non_modable_rel & non_elliptical_n_rel ],
                                CONT.HOOK.INDEX [ PRONTYPE not_pron,
                                                  SORT #sort ] ] ]. 
head-adj_int-prn-prn-appos_phrase := basic-appos-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX.PRONTYPE real_pron ],
    NON-HEAD-DTR.SYNSEM [ PUNCT [ LPUNCT comma_punct,
                                  RPUNCT comma_punct ],
                          LOCAL.CONT.HOOK.INDEX.PRONTYPE real_pron ] ]
"""
; muy poco, casi nada, que resñar.
""".   

head-adj_int-modnp-appos_phrase := basic-appos-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD noun & 
                                     [ KEYS.KEY modable_rel & time_n_rel ],
                            CONT.HOOK.INDEX.SORT mod & #sort ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun & [ KEYS.KEY modable_rel ],
                                      VAL.SPR < [ ] > ],
                                CONT.HOOK.INDEX [ PRONTYPE not_pron,
                                                  SORT #sort & tmp ] ] ].

head-adj_int-modnp-adv-appos_phrase := basic-appos-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD noun & 
                                     [ KEYS.KEY modable_rel ],
                            CONT.HOOK.INDEX.SORT mod & #sort ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD adv & [ KEYS.KEY adv_rel ],
                                      VAL.SPR < [ ] > ],
                                CONT.HOOK.INDEX.SORT #sort & non-temp ] ].

head-adj_int-nu-appos_phrase := basic-appos-phrase &
  [ HEAD-DTR.SYNSEM [ PUNCT.RPUNCT no_punct,
                      LOCAL.CAT [ HEAD.KEYS.KEY non_elliptical_n_rel,
                                  VAL.SPR < > ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun & [ KEYS.KEY non_modable_rel ],
                                      VAL.SPR < > ],
                                CONT.RELS <! [ PRED generic_entity_rel ], [ PRED card_q_rel ] !> ] ]
"""
; la propuesta 23
""".

head-adj_int-cmp-nu-appos_phrase := basic-appos-phrase &
  [ HEAD-DTR.SYNSEM [ PUNCT.RPUNCT no_punct,
                      LOCAL.CAT [ HEAD.KEYS.KEY non_elliptical_n_rel,
                                  VAL.SPR < > ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun & [ KEYS.KEY card_rel ],
                                      VAL.SPR < > ],
                                CONT.RELS <! [ PRED compound_rel ], 
                                             [ PRED undef_q_rel ], 
                                             relation, 
                                             [ PRED card_rel ], 
                                             [ PRED card_q_rel ] !> ] ]
"""
; la propuesta número 23
""".


; compounds

basic_n_n_cmpnd_phrase := head-valence-phrase & head-compositional & basic-binary-phrase &
  [ SYNSEM [ SLSHD #slshd,
             MODIFIED notmod,
             LOCAL.CAT [ MC #mc,
                         VAL #valence ] ],
    HEAD-DTR.SYNSEM [ SLSHD #slshd,
                      LOCAL [ COORD-STRAT zero,
                              CAT [ MC #mc,
                                    VAL #valence ] ] ],
    NON-HEAD-DTR.SYNSEM [ MODIFIED notmod, 
                          LOCAL [ CAT [ HEAD.KEYS.KEY common_nom_rel,
                                        VAL.COMPS < > ],
		                  CONT.HOOK.INDEX ref-ind ],
                          NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                      QUE 0-dlist,
                                      REL 0-dlist ] ] ].
		    
basic_np_name_cmpnd_phrase := basic_n_n_cmpnd_phrase &
  [ SYNSEM [ LIGHT +,
             LOCAL.CAT.HEAD.MOD < > ],
    HEAD-DTR.SYNSEM [ LIGHT +,
                      LOCAL [ CAT.HEAD noun,
                              CONT.HOOK.INDEX #ind ] ],
    NON-HEAD-DTR [ INFLECTED +,
                   SYNSEM [ LIGHT +,
                            LOCAL [ CAT.HEAD noun, 
                                    CONT.HOOK [ LTOP #nhltop,
                                                INDEX #nhind ] ] ] ],
    C-CONT [ RELS <! [ PRED compound_rel,
                       ARG1 #ind,
		       ARG2 #nhind ], 
                     [ PRED undef_q_rel,
                       ARG0 #nhind,
                       RSTR #rhand ] !>,
	     HCONS <! qeq & [ HARG #rhand,
                              LARG #nhltop ] !> ] ].


n_n_cmpnd_phrase := basic_np_name_cmpnd_phrase & head-initial & 
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY common_nom_rel,
                                  VAL.SPR < [ LOCAL.CAT.HEAD det,
                                              NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                                          QUE 0-dlist,
                                                          REL 0-dlist ] ] > ],
                            CONT.HOOK.INDEX [ PRONTYPE not_pron , SORT non-temp ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < [ LOCAL.CAT.HEAD det,
                                              NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                                          QUE 0-dlist,
                                                          REL 0-dlist ] ] > ]
"""
; e.g. coche bomba, mesa camilla,...
""".


n_n-num_cmpnd_phrase := basic_np_name_cmpnd_phrase & head-initial & 
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ VAL.SPR < [ LOCAL.CAT.HEAD det,
                                            NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                                        QUE 0-dlist,
                                                        REL 0-dlist ] ] > ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CONT.RELS <! [ PRED generic_entity_rel ], [ PRED card_q_rel ] !> ]
"""
; e.g. número dos
""".


; --- unary phrase types for optionality

optsubj_phrase := head-valence-phrase & head-only & head-compositional &
  [ INFLECTED #infl,
    SYNSEM [ MODIFIED #mod,
             SLSHD #slshd,
             LOCAL [ COORD #coord,
                     COORD-STRAT #cstrat,
                     CAT [ POSTHEAD +,
                           MC #mc,
                           POSTHEAD #ph,
                           VAL [ SUBJ < >,
                                 COMPS #comps,
                                 SPR #spr,
                                 SPEC #spec,
                                 CLTS #clit ] ] ],
             NON-LOCAL #nlocal ],
    HEAD-DTR [ INFLECTED #infl & +,
               SYNSEM [ MODIFIED #mod,
                        SLSHD #slshd,
                        LOCAL [ COORD #coord & -,
                                COORD-STRAT #cstrat & zero,
                                CAT [ MC #mc,
                                      POSTHEAD #ph, 
                                      HEAD verb & [ VFORM fin,
                                                    KEYS.KEY v_event_rel ],
                                      VAL [ SUBJ < [ OPT +,
                                                     LOCAL np_nom_local & 
                                                           [ CONT.HOOK.INDEX.DEF + ],
                                                     NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                                                 QUE 0-dlist,
                                                                 REL 0-dlist ] ] >,
                                            COMPS #comps & < >,
                                            SPR #spr,
                                            SPEC #spec & < >,
                                            CLTS #clit & < > ] ] ],
                        NON-LOCAL #nlocal ] ],
    C-CONT [ RELS  <! !>,
             HCONS <! !> ] ]
"""
; -- optional subject
""".


optcomp-phrase := head-valence-phrase & head-only & head-compositional &
  [ INFLECTED #infl,
    SYNSEM canonical-synsem &
           [ MODIFIED #mod,
             SLSHD #slshd,
             LIGHT -,
             LOCAL [ COORD #coord,
                     COORD-STRAT #cstrat,
                     CAT [ MC #mc,
                           VAL [ SUBJ #subj,
                                 COMPS #comps,
                                 SPR #spr,
                                 SPEC #spec,
                                 CLTS #clit ] ] ],
             NON-LOCAL #nlocal ],
    HEAD-DTR [ INFLECTED #infl & +,
               SYNSEM [ MODIFIED #mod, 
                        SLSHD #slshd,
                        LOCAL [ COORD #coord & -,
                                COORD-STRAT #cstrat & zero,
                                CAT [ MC #mc,
                                      VAL [ SUBJ #subj,
                                            SPR #spr,
                                            SPEC #spec,
                                            COMPS < [ OPT +,
                                                      NON-LOCAL [ QUE 0-dlist,
                                                                  REL 0-dlist ] ] 
                                                    . #comps >,
                                            CLTS #clit ] ] ],
                        NON-LOCAL #nlocal ] ],
    C-CONT [ RELS  <! !>,
             HCONS <! !> ] ]
"""
; -- optional complement
; The feature DEF-OPT allows the head to specify whether the optional
; complement is interpreted as definite (+), indefinite (-), or
; either (underspecified).  basic-head-opt-comp-phrase copies this
; information into the index of the unexpressed argument.
; Need to decide what to do about LIGHT here.  
;   [ SYNSEM.LOCAL.CAT.AGR #agr,
;     HEAD-DTR.SYNSEM.LOCAL.CAT.AGR #agr ] 
""". 

optcomp-v_phrase := optcomp-phrase &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD #ph,
                       VAL [ SUBJ.FIRST.LOCAL.AGR #agr,
                             COMPS #comps ] ],
    HEAD-DTR.SYNSEM.LOCAL [ STR.HEADED solely,
                            CAT [ POSTHEAD #ph, 
                                  HEAD verb & [ KEYS.KEY v_event_rel ],
                                  VAL [ SUBJ < [ LOCAL.AGR #agr ] >,
                                        COMPS < [ NON-LOCAL.SLASH 0-dlist ]. #comps > ] ] ] ]
"""; si diem que el subjecte no s'ha cancel·lat, no podem analitzar
; "volvió el hindú su rostro"
""". 

optcomp-n_phrase := optcomp-phrase &
  [ SYNSEM.LOCAL [ AGR #agr,
                   CAT [ POSTHEAD #ph,
                   VAL.COMPS #comps ],
		   CONT.HOOK.INDEX.SORT non-mod ],
    HEAD-DTR.SYNSEM [ MODIFIED notmod,
                      LOCAL [ AGR #agr,
                              STR.HEADED solely,
                              CAT [ POSTHEAD #ph, 
                                    HEAD noun,
                                    VAL.COMPS < [ NON-LOCAL.SLASH 0-dlist ]. #comps > ] ] ] ]. 

optcomp-a_phrase := optcomp-phrase &
  [ SYNSEM.LOCAL.CAT.POSTHEAD bool,
    HEAD-DTR.SYNSEM [ MODIFIED notmod,
                      LOCAL [ STR.HEADED solely,
                              CAT.HEAD adj ] ] ]. 

optcomp-r_phrase := optcomp-phrase &
  [ SYNSEM.LOCAL.CAT.POSTHEAD bool,
    HEAD-DTR.SYNSEM [ MODIFIED notmod,
                      LOCAL [ STR.HEADED solely,
                              CAT [ HEAD adv & [ KEYS.KEY basic_adv_rel ] ] ] ] ]. 


optspec_phrase := head-valence-phrase & non-clause & head-only & head-compositional & 
  [ INFLECTED #infl,
    SYNSEM [ MODIFIED #mod,
             LIGHT -,
             SLSHD #slshd,
             LOCAL [ COORD #coord,
                     COORD-STRAT #cstrat,
                     AGR #agr,
                     CAT [ MC #mc,
                           POSTHEAD #ph,
                           VAL [ SPR < >,
                                 SUBJ #subj,
                                 COMPS #comps,
                                 SPEC #spec ] ] ] ],
    HEAD-DTR [ INFLECTED #infl & +,
               SYNSEM [ MODIFIED #mod,
                        SLSHD #slshd,
                        LOCAL [ COORD #coord & -,
                                COORD-STRAT #cstrat & zero,
                                AGR #agr,
                                CAT [ MC #mc,
                                      POSTHEAD #ph, 
                                      HEAD noun,
                                      VAL [ SPR < [ OPT +, 
                                                    NON-LOCAL [ SLASH 0-dlist,
                                                                REL 0-dlist,
                                                                QUE 0-dlist ] ] >,
                                            SUBJ #subj,
                                            COMPS #comps & < >,
                                            SPEC #spec ] ] ] ] ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ]
"""
; -- optional specifier
""".


; --- unary phrase types for interjections

interj-phrase := head-valence-phrase & head-only & head-compositional & 
  [ INFLECTED #infl,
    SYNSEM synsem & 
           [ MODIFIED #mod,
             SLSHD #slshd,
             LIGHT -, 
             LOCAL #local,
             NON-LOCAL #nonloc ],
    HEAD-DTR [ INFLECTED #infl & +,
               SYNSEM [ MODIFIED #mod,
                        SLSHD #slshd,
                        LIGHT +, 
                        LOCAL #local & [ CAT.HEAD interj ],
                        NON-LOCAL #nonloc ] ],
    C-CONT [ RELS  <! !>,
             HCONS <! !> ] ].

interj-impropias-phrase := unary-phrase & 
  [ INFLECTED #infl,
    SYNSEM synsem & 
           [ LIGHT +, 
             SLSHD #slshd,
             LOCAL [ CAT [ HEAD interj,
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 CLTS < >,
                                 SPR < >,
                                 SPEC < > ] ],
                     CONT #cont ],
             NON-LOCAL #nonloc ],
    ARGS < [ INFLECTED #infl & +,
             SYNSEM [ PUNCT.RPUNCT excl_cl_punct, 
                      LIGHT +, 
                      SLSHD #slshd,
                      LOCAL [ CAT [ HEAD +nvjrp, 
                                    VAL.CLTS < > ],
                              CONT #cont ],
                      NON-LOCAL #nonloc ] ] >,
    C-CONT [ RELS  <! !>,
             HCONS <! !> ] ].

interj-impropias-cmp-phrase := head-valence-phrase & head-compositional & binary-phrase & 
  [ INFLECTED +,
    SYNSEM synsem & 
           [ LIGHT +, 
             SLSHD #slshd,
             LOCAL [ CAT [ HEAD interj,
                           VAL #val ] ] ],
    ARGS < [ INFLECTED +,
             SYNSEM [ LIGHT +, 
                      SLSHD #slshd,
                      LOCAL.CAT [ HEAD +nvjrp, 
                                  VAL.CLTS < > ] ] ],
           [ INFLECTED +,
             SYNSEM [ LIGHT +, 
                      LOCAL.CAT [ HEAD interj,
                                  VAL #val ] ] ] >,
    C-CONT [ RELS  <! !>,
             HCONS <! !> ] ].
; interj_improp_cmp_constr := interj-impropias-cmp-phrase & rule. 

; --- unary phrase types for Nbare (distinguished by the INDEX [ DIVISIBLE + ])

basic-nbar-phrase := unary-phrase &
  [ SYNSEM synsem & 
           [ LIGHT -, 
             SLSHD #slshd,
             LOCAL [ COORD #coord & -,
                     COORD-STRAT #coord-strat,
                     AGR ref-ind,
                     STR [ HEADING no,
                           HEADED solely ],
                     CAT [ MC na,
                           HEAD noun & 
                                [ MOD #mod,
                                  PRD #prd,
                                  TAM #tam, 
                                  CASE #case ], 
                           VAL [ SUBJ < >,
                                 COMPS #comps,
                                 SPR < > ] ] ],
             NON-LOCAL #nonloc ],
    C-CONT [ HOOK [ INDEX #index,
                    XARG #nhand ],
             RELS  <! [ PRED quant_rel,
                        ARG0 #index, 
                        RSTR #rhand ] !>,
             HCONS <! qeq & 
                      [ HARG #rhand, 
                        LARG #nhand ] !> ],
    ARGS < [ SYNSEM [ SLSHD #slshd,
                      LOCAL [ COORD #coord,
                              COORD-STRAT #coord-strat,
                              STR.HEADING solely,
                              CAT [ MC na,
                                    HEAD noun & 
                                         [ MOD #mod,
                                           PRD #prd,
                                           TAM #tam, 
                                           CASE #case ],
                                    VAL [ SUBJ olist,
                                          COMPS #comps & < >,
                                          SPR < [ OPT -,
                                                  LOCAL.CONT.RELS.LIST < relation >, 
                                                  NON-LOCAL [ SLASH 0-dlist,
                                                              REL 0-dlist,
                                                              QUE 0-dlist ] ] > ] ],
                              CONT.HOOK.LTOP #nhand ],
                      NON-LOCAL #nonloc ] ] > ].

nbar_phrase := basic-nbar-phrase &
  [ SYNSEM [ LOCAL [ AGR [ PNG #png,
                           DIVISIBLE + ],
                     CAT.HEAD.KEYS [ KEY #key, ALTKEY impl_undef_q_rel ] ],
             MODIFIED #modif ],
    ARGS < [ SYNSEM [ MODIFIED #modif,
                      LOCAL [ COORD-STRAT zero,
                              AGR [ PNG #png,
                                    DIVISIBLE + ],
                              CAT [ HEAD.KEYS.KEY #key & non_free_relative_nom_rel,
                                    VAL.SPR < unexpressed & 
                                              [ LOCAL.CAT.HEAD.KEYS.KEY abstr_def_or_udef_q_rel ] > ],
                              CONT.HOOK.INDEX #index ],
                      NON-LOCAL.REL 0-dlist ] ] >,
    C-CONT [ HOOK.INDEX #index,
             RELS <! [ PRED udef_q_rel ] !> ] ].

nbar-coord_phrase := basic-nbar-phrase &
  [ SYNSEM [ LOCAL [ AGR [ PNG [ PN 3pl,
                                 GEN #gender ],
                           DIVISIBLE + ],
                     CAT.HEAD.KEYS [ KEY #key, 
                                     ALTKEY impl_undef_q_rel ] ],
             MODIFIED #modif ],
    ARGS < [ SYNSEM [ LOCAL [ COORD-STRAT one,
                              AGR [ PNG.GEN #gender, 
                                    DIVISIBLE + ],
                              CAT [ HEAD.KEYS.KEY #key & common_nom_rel,      
                                    VAL.SPR < unexpressed & 
                                              [ LOCAL.CAT.HEAD.KEYS.KEY abstr_def_or_udef_q_rel ] > ],
			      CONT.HOOK.INDEX #index & 
                                              [ SORT #sort, 
                                                PRONTYPE #pronty ] ],
                      MODIFIED #modif ] ] >,
    C-CONT [ HOOK.INDEX #index & [ SORT #sort, PRONTYPE #pronty ],
             RELS <! [ PRED udef_q_rel ] !> ] ].

nbar-rel_phrase := unary-phrase &
  [ INFLECTED #infl,
    SYNSEM synsem & 
           [ SLSHD #slshd,
             MODIFIED #modif,
             LOCAL [ COORD #coord,
                     COORD-STRAT #coord-strat,
                     COORD-REL #crel,
                     AGR  #agr & ref-ind & [ PNG #png ],
                     CAT [ MC na,
                           HEAD noun & 
                                [ KEYS [ KEY que_pron_rel,
                                         ALTKEY proper_q_rel ], 
                                  CASE #case,
                                  TAM #tam,
                                  PRD #prd,
                                  MOD #mod ],       
                           VAL [ SUBJ < >,
                                 COMPS #comps,
                                 SPR < > ] ] ],
             NON-LOCAL #nonloc ],
    C-CONT [ HOOK #hook,
             RELS  <! !>,
             HCONS <! !> ],
    ARGS < [ INFLECTED #infl,
             SYNSEM [ PUNCT.RPUNCT no_punct,
                      SLSHD #slshd,
                      MODIFIED #modif,
                      LOCAL [ COORD #coord & -,
                              COORD-STRAT #coord-strat & zero,
                              COORD-REL #crel,
                              AGR #agr & [ PNG #png ], 
                              CAT [ MC na,
                                    HEAD noun & 
                                         [ KEYS [ KEY que_pron_rel,
                                                  ALTKEY def_q_rel ], 
                                           CASE #case,
                                           TAM #tam,
                                           PRD #prd,
                                           MOD #mod  ],
                                    VAL [ SUBJ olist,
                                          COMPS #comps & < >,
                                          SPR < [ OPT -,
                                                  LOCAL.CONT.RELS.LIST < relation >, 
                                                  NON-LOCAL [ SLASH 0-dlist,
                                                              REL 0-dlist,
                                                              QUE 0-dlist ] ] > ]],
                              CONT.HOOK #hook ],
                      NON-LOCAL #nonloc & [ REL 1-dlist ] ] ] > ].


npred_phrase := unary-phrase & 
  [ INFLECTED +,
    SYNSEM [ PUNCT #punct,
             SLSHD #slshd,
             LOCAL [ CAT [ HEAD non-partn & [ KEYS.KEY #key,
                                         MOD #mod,
                                         PRD prd & [ COPV ser ],
                                         CASE #case ],
                           VAL [ SPR < >,
                                 COMPS #comps ] ],
                     CONT #cont,
                     CTXT #ctxt,
                     COORD #coord,
                     COORD-STRAT #coord-strat,
                     COORD-REL #coord-rel ],
             NON-LOCAL #nonloc ],
    ARGS < [ INFLECTED +,
             SYNSEM [ PUNCT #punct & [ RPUNCT no_punct ],
                      SLSHD #slshd,
                      LOCAL [ AGR.DIVISIBLE -,
                              CAT [ HEAD non-partn & [ PRD non-prd,
                                               KEYS.KEY #key & predicative_n_rel,
                                               CASE #case,
                                               MOD #mod ],
                                    VAL [ SPR < [ OPT - ] >,
                                          COMPS #comps ] ],
                              CONT #cont,
                              CTXT #ctxt,
                              COORD #coord,
                              COORD-STRAT #coord-strat,
                              COORD-REL #coord-rel ],
                      NON-LOCAL #nonloc ] ] > ]
 
"""
For allowing common nouns serve as predicates/complements to ser: "Es profesor." - but not to drop the specifier in other contexts.
""". 


; --- unary phrase types for adverbial-NP modifiers


basic-npadv-phrase := basic-unary-phrase & phrasal &
  [  INFLECTED +,
     SYNSEM [ PUNCT #punct,
             SLSHD #slshd,
             LOCAL [ COORD #coord,
                     COORD-STRAT #coord-strat,
                     COORD-REL #crel,
                     ;AGR #agr,
                     CAT [ POSTHEAD +, 
                           HEAD modnp &
				[ MOD < [ LOCAL intersective-mod &
				 	        [  ;AGR #agr,
				 	           COORD -,
                                                  CAT.MC #mc,
                                                  CONT.HOOK [ INDEX #ind,
                                                              LTOP #ltop ] ],
                                          NON-LOCAL [ REL 0-dlist ] ] >,
                                  TAM #tam,
                                  KEYS.KEY prep_mod_rel,
                                  PRD #prd ],
			   VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
			   MC #mc ],
		     CONT.HOOK [ LTOP #ltop,
                                 XARG #ind ],
                     CTXT #ctxt ],
             NON-LOCAL #nonloc ],
    ARGS < [ INFLECTED +,
             SYNSEM [ PUNCT #punct,
                      SLSHD #slshd,
                      LOCAL [ AGR.SORT mod,
                              COORD #coord & -,
                              COORD-STRAT #coord-strat & zero,
                              COORD-REL #crel,
                              CAT [ HEAD.PRD #prd,
                                    VAL [ SPR < >,
                                          SUBJ < >,
					  COMPS < > ] ],
                              CTXT #ctxt ],
                      NON-LOCAL #nonloc ] ] >,
    C-CONT [ HOOK [ LTOP #khand,
                    INDEX #arg0 ],
	     RELS <! prep-relation &
                     [ LBL #khand,
                       PRED unspec_loc_rel,
                       ARG0 #arg0 & [ E #tam ],
                       ARG1 #ind & event-or-ref-index ] !>,
	     HCONS <! !> ] ].

npadv_phrase := basic-npadv-phrase &
  [ SYNSEM.LOCAL [ AGR #agr,
                   CAT.HEAD [ MOD < [ LOCAL [ AGR #agr,
                                              CAT.HEAD +nv ] ] >,
                              CASE #case,
                              KEYS.ALTKEY #argkey ],
                   CONT.HOOK.INDEX [ SORT #sort ] ],
    ARGS < [ SYNSEM.LOCAL [ AGR [ DIVISIBLE + ],
                            CAT [ HEAD noun & 
                                       [ KEYS.KEY adv_n_rel & #argkey,
                                         CASE #case ] ],
		            CONT.HOOK.INDEX #index & [ SORT #sort & mod ] ] ] >,
    C-CONT.RELS <! prep-relation &
                   [ ARG2 #index ] !> ].

npadv_modn_phrase := basic-npadv-phrase &
  [ SYNSEM.LOCAL [ AGR #ind,
                   CAT.HEAD [ MOD < [ LOCAL [ CAT [ HEAD noun,
                                                    POSTHEAD + ],
                                              CONT.HOOK.INDEX #ind ] ] >,
                              CASE #case,
                              KEYS.ALTKEY #argkey ],
                   CONT.HOOK.INDEX.SORT #sort ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun & 
                                       [ KEYS.KEY modable_rel & #argkey,
                                         CASE #case ] ],
		            CONT.HOOK.INDEX #index & [ SORT #sort & mod ] ] ] >,
    C-CONT.RELS <! prep-relation &
                   [ ARG2 #index ] !> ].


vocative_np_phrase := basic-unary-phrase & phrasal & 
  [ INFLECTED +,
    SYNSEM [ PUNCT #punct,
             SLSHD #slshd,
             LOCAL [ COORD #coord,
                     COORD-STRAT #coord-strat,
                     COORD-REL #crel,
                     AGR #ind,
                     CAT [ HEAD modnp &
				[ MOD < [ LOCAL scopal-mod &
                                                [ COORD -,
                                                  CAT [ MC #mc,
                                                        HEAD verb,
                                                        VAL.SUBJ < > ],
                                                  CONT.HOOK [ LTOP #ltop,
                                                              INDEX #arg2 ] ],
                                          NON-LOCAL.REL 0-dlist ] >,
                                  CASE #case,
                                  KEYS [ KEY prep_mod_rel,
                                         ALTKEY #argkey ] ],
			   VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ],
			   MC #mc ],
		     CONT.HOOK [ LTOP #ltop,
                                 XARG #ind ],
                     CTXT #ctxt ],
              NON-LOCAL #nonloc ],
    ARGS < [ INFLECTED +,
             SYNSEM [ SLSHD #slshd,
                      PUNCT #punct & [ RPUNCT comma_punct ],
                      LOCAL [ COORD #coord & -,
                              COORD-STRAT zero & #coord-strat,
                              COORD-REL #crel,
                              CAT [ HEAD non-partn & 
                                        [ PRD non-prd,
                                          KEYS.KEY named_rel & #argkey,
                                          CASE #case ],
                                    VAL [ SPR < >,
                                          COMPS < > ] ],
                              CONT.HOOK.INDEX #arg1,
                              CTXT #ctxt ],
                     NON-LOCAL #nonloc ] ] >,
   C-CONT [ HOOK [ LTOP #ltop,
                   INDEX #arg2 ],
            RELS <! [ LBL #ltop,
                      PRED addressee_rel,
                      ARG1 #arg1,
                      ARG2 #arg2 ] !>,
            HCONS <! !> ] ]
"""
; unary phrase types for vocatives
""".

vocative_np_prh_phrase := vocative_np_phrase &
[ SYNSEM [ PUNCT [ LPUNCT no_punct,
                   RPUNCT comma_punct ],
           LOCAL.CAT.POSTHEAD -] ].
   
vocative_np_psth_phrase  := vocative_np_phrase &
[ SYNSEM [ PUNCT.LPUNCT comma_punct, 
           LOCAL.CAT.POSTHEAD + ] ].


partitive_num_phrase := basic-unary-phrase & phrasal &
  [ SYNSEM [ PUNCT #punct,
             SLSHD #slshd,
             LOCAL [ COORD #coord,
                     COORD-STRAT #coord-strat,
                     COORD-REL #crel,
                     AGR [ PNG.PN 3per,
                           DIVISIBLE + ],
                     CAT [ HEAD partn &
                                [ KEYS.KEY part_of_rel,
                                  MOD < > ],
                           VAL [ SPR < [ OPT + ] >,
                                 SPEC < >,
                                 SUBJ < >,
                                 COMPS < > ] ],
                     CONT nom-obj,
                     CTXT #ctxt ],
             NON-LOCAL #nonloc ],
    ARGS < [ INFLECTED +,
             SYNSEM [ PUNCT #punct,
                      SLSHD #slshd,
                      LOCAL [ COORD #coord & -,
                              COORD-STRAT #coord-strat,
                              COORD-REL #crel,
                              CAT [ HEAD adj &
			                 [ KEYS [ KEY compar_adj_rel,
                                                  ALTKEY compar ],
				           MOD < synsem > ],
			            VAL [ SUBJ < >,
			                  COMPS < >,
                                          SPR < [ ] > ] ],
		              CONT [ HOOK [ LTOP #nhand,
			                    XARG #index ],
                                     RELS.LIST < adj-arg1-relation, [ PRED compar ], ... > ],
                              CTXT #ctxt ],
                      NON-LOCAL #nonloc & 
                                [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ] >,
    C-CONT [ HOOK [ LTOP #nhand,
                    INDEX #index,
                    XARG #nhand ],
	     RELS <! [ PRED generic_entity_rel,
                       LBL #nhand,
                       ARG0 #index ] !>,
	     HCONS <! !> ] ]
"""
; más de dos niños
""".


; --- unary phrase types for gerundive constructions

vger_phrase := unary-phrase & 
  [ SYNSEM [ LIGHT -,
	     SLSHD #slshd,
             MODIFIED #hasmod,
             PUNCT #punct,
             LOCAL [ AGR #ind,
                     COORD #coord,
                     COORD-STRAT #coord-strat,
                     COORD-REL #crel,
                     CAT [ POSTHEAD +,
                           HEAD verb & 
                              [ VFORM #vform,
                                TAM #tam,
                                AUX #aux,
                                INV #inv,
                                KEYS.KEY #key,
                                LSYNSEM #lsynsem,
                                MOD < [ LOCAL intersective-mod &
                                              [ CAT.HEAD +nv,
                                                CONT.HOOK.LTOP #modltop ],
                                        NON-LOCAL [ QUE 0-dlist,
                                                    REL 0-dlist ] ] > ],
			   VAL #val ],
                     CTXT #ctxt ],
             NON-LOCAL #nonloc ],
    ARGS < [ SYNSEM [ SLSHD #slshd,
                      MODIFIED #hasmod,
                      PUNCT #punct, 
                      LOCAL [ AGR #ind,
                              COORD #coord & -,
                              COORD-STRAT #coord-strat,
                              COORD-REL #crel,
                              CAT [ HEAD verb & 
                                         [ VFORM #vform & ger,
                                           TAM #tam,
                                           AUX #aux,
                                           INV #inv,
                                           KEYS.KEY #key & v_event_rel,
                                           LSYNSEM #lsynsem,
                                           MOD < > ],
			            VAL #val & [ SPR < >,
					         COMPS < >,
					         CLTS < > ] ],
			      CONT.HOOK [ LTOP #vpltop,
                                          INDEX.SF prop ],
                              CTXT #ctxt ],
                      NON-LOCAL #nonloc ] ] >,
;                     NON-LOCAL #nonloc &
;                               [ SLASH 0-dlist & [ LIST < > ],
;                                 QUE 0-dlist,
;                                 REL 0-dlist ] ] ] >,
    C-CONT [ HOOK [ INDEX #event,
                    LTOP #ltop ], 
             RELS <! subord-relation &
                     [ PRED subord_rel,
		       LBL #ltop,
                       ARG0 #event,
                       ARG1 #main,
                       ARG2 #subord ] !>,
             HCONS <! qeq & [ HARG #main, LARG #modltop ], 
                      qeq & [ HARG #subord, LARG #vpltop ] !> ] ].

adjpart_phrase := unary-phrase & 
  [ SYNSEM [ LIGHT -,
             SLSHD #slshd,
             LOCAL [ AGR #agr,
                     COORD #coord & -,
                     COORD-STRAT #coord-strat & zero,
                     CAT [ HEAD adj &
                               [ PRD  [ HABER #haber & - ],
                                 MOD < synsem &
                                       [ LOCAL intersective-mod &
                                               [ AGR #agr,
                                                 CAT [ LASTNMOD -,
                                                       HEAD noun & [ KEYS.KEY nom_rel ],
                                                       VAL [ SUBJ < >,
                                                             SPEC < > ] ],
                                                 CONT.HOOK.INDEX #ind ] ] >,
                                 KEYS.KEY v_event_rel ],
                           VAL [ SPR < >,
                                 SUBJ < >,
                                 COMPS #comps,
                                 CLTS #clts,
                                 SPEC < > ] ],
                    CONT #cont,
                    CTXT #ctxt ],
	    NON-LOCAL #non-local & [ QUE 0-dlist ] ],
    ARGS < [ INFLECTED +,
             SYNSEM [ SLSHD #slshd,
                      LOCAL [ COORD #coord,
                              COORD-STRAT #coord-strat,
                              CAT [ HEAD verb &
                                         [ PRD.HABER #haber,
                                           AUX -,
                                           VFORM part,
                                           VOICE passive,
                                           MOD < >,
                                           KEYS.KEY v_event_rel ],
			   	    VAL [ SUBJ < [ LOCAL [ AGR #agr,
			   	                           CONT.HOOK.INDEX #ind ] ] >,
                                          COMPS #comps & < >,
                                          CLTS #clts ] ],
                              CONT #cont & [ HOOK #hook ],
                              CTXT #ctxt ],
                      NON-LOCAL #non-local ] ] >,
    C-CONT [ HOOK #hook,
             RELS <! !>,
             HCONS <! !> ] ]
"""
; --- unary phrase type for adj-pastpart
; removed "PRD non-prd" to deal with esos tíos son muy pesados
""".

prdp_phrase := unary-phrase & 
  [ SYNSEM [ LIGHT -,
	     MODIFIED #hasmod,
;	     LIGHT #light,
             SLSHD #slshd,
             LOCAL [ COORD #coord,
                     COORD-STRAT #coord-strat,
                     COORD-REL #crel,
                     CAT [ MC na,
                           POSTHEAD +,
                           HEAD adp &
				[ KEYS #keys,
                                  MOD < [ LOCAL intersective-mod &
                                                [ COORD -,
                                                  CAT [ HEAD verb,
                                                        VAL.SUBJ < [ LOCAL.AGR #agr ] > ],
                                                  CONT.HOOK.LTOP #modltop ] ] > ],
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 SPR < >,
                                 SPEC < >] ],
                    CTXT #ctxt ],
             NON-LOCAL #non-local ],
    ARGS < [ SYNSEM [ MODIFIED #hasmod,
;                     LIGHT #light,
                      SLSHD #slshd,
                      LOCAL [ COORD #coord & -,
                              COORD-STRAT #coord-strat,
                              COORD-REL #crel,
                              CAT [ MC na,
                                    HEAD adj & 
                                         [ ;PRD non-prd,
                                           KEYS #keys,
                                           MOD < [ LOCAL intersective-mod & 
                                                         [ AGR #agr,
                                                           CAT.HEAD noun ] ] > ],
                                    VAL [ SUBJ < >,
                                          COMPS < >,
                                          SPEC < >,
                                          CLTS < > ] ],
                              CONT.HOOK.LTOP #vpltop,
                              CTXT #ctxt ],
		      NON-LOCAL #non-local &
                                [ SLASH 0-dlist & [ LIST < > ],
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ] >,
    C-CONT [ HOOK [ INDEX #event,
                    LTOP #ltop ],
	     RELS <! subord-relation & 
                     [ PRED subord_rel,
		       LBL #ltop,
                       ARG0 #event,
                       ARG1 #main,
                       ARG2 #subord ] !>,
             HCONS <! qeq & [ HARG #main, LARG #modltop ], 
                      qeq & [ HARG #subord, LARG #vpltop ] !> ] ]
"""
; --- unary phrase type for predicative phrases
; The adjective is not required to be POSTHEAD + to deal with "manipular mejor", comparative adjectives are POSTHEAD -
""".


cpa_phrase := unary-phrase & phrasal &
  [ SYNSEM [ PUNCT.RPUNCT comma_punct,
             SLSHD #slshd,
             LOCAL [ AGR #ind,
                     COORD #coord,
                     COORD-STRAT #coord-strat,
                     CAT [ MC -,
                           POSTHEAD -,
                           HEAD verb &
                               [ PRD #prd,
                                 AUX #aux,
                                 VFORM #vform,
                                 VOICE #voice,
                                 KEYS #keys,
                                 LSYNSEM #lsynsem,
                                 MOD < synsem &
                                       [ LOCAL scopal-mod &
                                               [ CAT [ HEAD verb & [ VFORM fin ],
                                                       VAL [ SPR < >,
                                                             SUBJ < >,
                                                             COMPS < >,
                                                             SPEC < > ] ],
                                                 CONT [ HOOK.LTOP #larg1,
                                                        RELS <! [ LBL #larg1 ] !> ] ] ] > ],
                           VAL #val ],
                     CTXT #ctxt ],
	    NON-LOCAL #non-local ],
   ARGS < [ INFLECTED +,
            SYNSEM [ SLSHD #slshd,
                     LOCAL [ AGR #ind,
                             COORD #coord,
                             COORD-STRAT #coord-strat,
                             CAT [ HEAD verb &
                                        [ INV +,
                                          AUX #aux & -,
                                          VFORM #vform & part,
                                          VOICE #voice & passive,
                                          PRD #prd & non-prd, 
                                          KEYS #keys,
                                          LSYNSEM #lsynsem,
                                          MOD < > ],
			     	   VAL #val & [ SUBJ < > ] ],
			     CONT [ HOOK.LTOP #larg2 ],
                             CTXT #ctxt ],
                     NON-LOCAL #non-local ] ] >,
    C-CONT [ RELS <! [ PRED subord_rel,
                       ARG1 #arg1,
                       ARG2 #arg2 ] !>,
             HCONS <! [ HARG #arg1, LARG #larg1 ],
                      [ HARG #arg2, LARG #larg2 ] !> ] ]
"""
; --- unary phrase types for "construcciones de participio absoluto". 
; Verb (transitive/unaccusative) passive participle + non-pronominal NP (subject)
; e.g. acabada *ella/la reunión, todos se pusieron a trabajar. 
""".

cp-nom_phrase := unary-phrase & phrasal &
  [ SYNSEM [ SLSHD #slshd,
             LOCAL [ AGR.PNG.PN 3sg,
                     CAT [ MC na,
                           HEAD noun & 
                                [ MOD < >,
                                  KEYS.KEY nominalization_rel ],
                           VAL [ SUBJ < >,
                                 SPR < [ LOCAL.CAT.HEAD.KEYS.KEY art_def_q_rel ] >,
                                 COMPS < >,
                                 SPEC < >,
                                 CLTS < > ] ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ] ],
    ARGS < [ SYNSEM [ SLSHD #slshd,
                      LIGHT -,
                      LOCAL [ CAT [ MC -,
                                    HEAD comp & 
                                         [ VFORM fin,
                                           TAM.MOOD ind_or_sub_mood ],
                                    VAL [ SUBJ < >, 
                                          COMPS < > ] ],
                              CONT.HOOK [ LTOP #chand,
                                          XARG ref-ind ] ],
                      NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ] >,
    C-CONT [ HOOK.INDEX #index & ref-ind & [ PNG.PN 3sg ],
	     RELS <! nominalize-relation &
                     [ ARG0 #index,
                       ARG1 #chand ] !> ] ]
"""
; --- unary phrase types adding the article to finite completive clauses
; e.g. "El que haya dicho esto no me importa"
""".

vp-nom_phrase := unary-phrase & phrasal &
  [ SYNSEM [ MODIFIED notmod,
             SLSHD #slshd,
             PUNCT #punct,
             LOCAL [ COORD -,
                     COORD-STRAT zero,
                     AGR [ PNG.PN 3sg,
                           DIVISIBLE + ], 
                     CAT [ MC na,
                           HEAD +np & 
                                [ MOD < >,
                                  KEYS.KEY nominalization_rel ],
                           VAL [ SUBJ < >,
                                 SPR < [ OPT -,
                                         LOCAL.CAT.HEAD.KEYS.KEY art_def_q_rel ] >,
                                 COMPS < >,
                                 SPEC < >,
                                 CLTS < > ] ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ] ],
    ARGS < [ SYNSEM [ PUNCT #punct,
                      SLSHD #slshd,
                      LOCAL [ CAT [ MC -,
                                    HEAD verb & 
                                         [ AUX -,
                                           VFORM inf,
                                           KEYS.KEY v_event_rel ],
                                    VAL [ COMPS < >,
                                          CLTS < > ] ],
                              CONT.HOOK [ LTOP #chand,
                                          XARG ref-ind ] ],
                      NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ] >,
    C-CONT [ HOOK.INDEX #index & ref-ind & 
                        [ PNG.PN 3sg,
                          PRONTYPE not_pron ],
	     RELS <! nominalize-relation &
                     [ ARG0 #index,
                       ARG1 #chand ] !> ] ]
"""
; --- unary phrase types adding the article to VP inf
; e.g. 
""".

; --- phrase types for ellipsis

basic-ellipis-phrase := basic-headed-phrase & phrasal & basic-binary-phrase & 
  [ INFLECTED +,
    SYNSEM [ MODIFIED #modif,
             SLSHD #slshd,
             LOCAL [ COORD -,
                     COORD-STRAT #coord-strat,
                     STR.HEADED right,
                     AGR #agr,
                     CAT [ MC na,
                           POSTHEAD #hdph,
                           HEAD noun & [ MOD < >,
                                  PRD #prd,
                                  TAM #tam, 
                                  CASE #case,
                                  KEYS.KEY elliptical_n_rel ], 
                           VAL [ SUBJ #subj,
                                 COMPS #spcomps,
                                 SPEC #spec,
                                 CLTS #clit,
                                 SPR #spr & < > ] ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ] ],
    HEAD-DTR #head-dtr & 
             [ INFLECTED +,
               SYNSEM [ SLSHD #slshd,
                        MODIFIED #hmodif,
                        LOCAL [ COORD -,
                                COORD-STRAT #coord-strat,
                                STR.HEADING right,
                                CAT [ POSTHEAD #hdph,
                                      HEAD [ MOD < [ NON-LOCAL.REL 0-dlist,
                                                     LOCAL [ CAT [ MC na,
                                                                   HEAD noun & 
                                                                        [ MOD < >,
                                                                          PRD #prd,
                                                                          TAM #tam, 
                                                                          CASE #case,
                                                                          KEYS.KEY non_modable_rel ],
                                                                   VAL  [ SUBJ < >,
                                                                          COMPS < >,
                                                                          SPEC < >,
                                                                          SPR < #synsem . #spr >, 
                                                                          CLTS < > ] ],
                                                             CONT.HOOK #hdhook & [ INDEX #agr ] ] ] > ],
                                      VAL [ SUBJ #subj & < >,
                                            COMPS < >,
                                            SPEC #spec & < >,
                                            CLTS #clit & < > ] ] ],
                        NON-LOCAL [ SLASH 0-dlist,
	                    	    QUE 0-dlist ] ] ],
    NON-HEAD-DTR #non-head-dtr &
                 [ INFLECTED +,
                   SYNSEM #synsem & 
                          [ MODIFIED #modif,
                            LOCAL [ COORD -,
                                    AGR #agr,
                                    CAT [ POSTHEAD -,
                                          HEAD det,
                                          VAL [ SPEC < [ MODIFIED #hmodif,
                                                         LOCAL.CONT.HOOK #hdhook & [ LTOP #larg ] ] >,
                                                COMPS #spcomps ] ],
                                    CONT [ HOOK #hook,
                                           HCONS.LIST < qeq & [ LARG #larg ], ... > ] ] ] ],
    ARGS < #non-head-dtr, #head-dtr >,
    C-CONT [ HOOK #hook & [ INDEX #arg0 & [ PRONTYPE not_pron ] ],
             RELS  <! [ PRED elliptical_n_rel,
                        LBL #larg,
                        ARG0 #arg0 ]!>,
             HCONS <! !> ] ].

np_ell_phrase := basic-ellipis-phrase & binary-punct-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.ALTKEY _el_q_rel, 
    HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD +vjp & [ MOD < [ LOCAL.CAT.HEAD.KEYS.ALTKEY def_q_rel ] > ],
                      NON-LOCAL.REL 0-dlist ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.KEYS.ALTKEY def_q_rel ] > ]
"""
; removed SYNSEM.LOCAL.STR.HEADING right_or_no, to deal with "el próximo, quizá"
""".

np_ell-indef_phrase := basic-ellipis-phrase & binary-punct-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.ALTKEY art_indef_q_rel, 
    HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD adj & [ MOD < [ LOCAL.CAT.HEAD.KEYS.ALTKEY art_indef_q_rel ] > ],
                      NON-LOCAL.REL 0-dlist ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.HEAD.KEYS.ALTKEY art_indef_q_rel ] > ].


np_ell-sfrel_phrase := basic-ellipis-phrase & 
  [ SYNSEM.LOCAL.STR.HEADING no,
    HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD verb & 
                                     [ VFORM fin,
                                       TAM.MOOD ind_or_sub_mood,
                                       MOD < [ LOCAL [ CAT.HEAD.KEYS.KEY non_named_non_modable_rel,
                                                       CONT.HOOK.INDEX.SORT non-temp ] ] > ],
                      NON-LOCAL.REL 1-dlist ] ]
"""
; -- semi-free relatives (e.g. el/aquel que te dijo eso no conoce las raíces del conflicto)
; - el artículo determinado, o pron. demostrativo, informa de los rasgos de género y número 
; del antecedente elíptico
; - "quien", "el cual", "cuyo" y los relativos adverbiales no pueden aparecer nunca en r.semilibres
; - "el + que" puede aparecer siempre que no vaya precedido de preposición. Una rel. semilibre sólo 
; puede aparecer encabezada por preposición cuando esta toma como término al relativo, cuando es 
; el verbo de la subordinada el que la selecciona (e.g. aquella de (la) que te hablé era espectacular).
; Pero si el determinante del antecedente es el artículo, tales casos son siempre agramaticales 
; (e.g. *la de (la) que te hablé era espectacular).
""".


; --- filler-head-phrase types

basic-filler-phrase := binary-phrase & phrasal &
  [ SYNSEM [ SLSHD #slshd,
             LOCAL.CAT [ VAL [ COMPS < >,
                               SPR < >,
                               CLTS #clit ] ],
	     NON-LOCAL.SLASH 0-dlist ],
    ARGS < [ SYNSEM [ LOCAL #slash & local &
                             [ CAT.VAL [ SUBJ olist,
                                         COMPS olist,
                                         CLTS < > ],
                               CTXT.ACTIVATED + ],
                      NON-LOCAL.SLASH 0-dlist ] ],
           [ SYNSEM [ SLSHD #slshd,
                      LOCAL.CAT [ HEAD verb,
                                  VAL [ COMPS < >,
                                        CLTS #clit & < > ] ],
                      NON-LOCAL [ SLASH 1-dlist &
                                        [ LIST [ FIRST #slash,
                                                 REST < > & #last ],
                                          LAST #last ],
                                  REL 0-dlist ] ] ] > ].

basic-head-filler-phrase := basic-filler-phrase & headed-phrase.

filler-head-phrase := basic-filler-phrase & 
  [ SYNSEM [ LOCAL.CAT.VAL [ SUBJ #subj,
                             SPR < > ],
	     NON-LOCAL.QUE 0-dlist ] ,
    ARGS < [ INFLECTED + ],
           [ SYNSEM.LOCAL.CAT.VAL.SUBJ #subj ] > ].

filler-head-phrase-fin := binary-phrase & phrasal &
  [ ARGS < [ INFLECTED + ],
           [ SYNSEM.LOCAL.CAT [ HEAD.TAM.MOOD ind_or_sub_mood,
                                VAL.SUBJ < > ] ] > ].

filler-head-phrase-inf := binary-phrase & phrasal &
  [ ARGS < [ INFLECTED + ],
           [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf,
                                VAL.SUBJ < [ OPT +,
                                             LOCAL.CONT.HOOK.INDEX ref-ind,
                                             NON-LOCAL [ SLASH 0-dlist,
                                                         REL 0-dlist,
                                                         QUE 0-dlist ] ] > ] ] > ].

filler-head-phrase-nonfin := binary-phrase & phrasal &
  [ ARGS < [ INFLECTED + ],
           [ SYNSEM.LOCAL.CAT [ HEAD.VFORM nonfin,
                                VAL.SUBJ < [ OPT +,
                                             LOCAL.CONT.HOOK.INDEX ref-ind,
                                             NON-LOCAL [ SLASH 0-dlist,
                                                         REL 0-dlist,
                                                         QUE 0-dlist ] ] > ] ] > ].
                                                                  
; --- filler-head phrase types for wh

filler-head-wh-phrase := filler-head-phrase & basic-headed-phrase &
  [ ARGS < [ SYNSEM.NON-LOCAL.QUE <! [ ] !> ],
           [ SYNSEM.LOCAL.CAT.HEAD [ KEYS [ ALTKEY ques,
                                            ALT2KEY ques ],
                                     MOD < > ] ] >,
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].   

wh-int-clause := interrogative-clause & basic-binary-phrase &
  [ SYNSEM.LOCAL.CAT [ MC bool,
                       HEAD verb & 
                            [ KEYS #keys,
                              PRD #prd,
                              INV #inv,
                              VFORM #vform,
                              AUX #aux,
                              TAM #tam,
                              VOICE #voice,
                              MOD #mod,
                              LSYNSEM #lsynsem ] ],
    HEAD-DTR #head-dtr & 
             [ SYNSEM.LOCAL.CAT.HEAD verb & 
                                     [ KEYS #keys,
                                       PRD #prd,
                                       INV #inv,
                                       VFORM #vform,
                                       AUX #aux,
                                       TAM #tam,
                                       VOICE #voice,
                                       MOD #mod,
                                       LSYNSEM #lsynsem ] ],
    NON-HEAD-DTR #non-head-dtr &
                 [ SYNSEM.NON-LOCAL.QUE 1-dlist ],
    ARGS < #non-head-dtr, #head-dtr > ].

filler-head_wh-fin_phrase := filler-head-wh-phrase & wh-int-clause &
  [ ARGS < [ INFLECTED + ],
           [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin,
                                       TAM.MOOD ind_or_sub_mood ],
                                VAL.SUBJ < > ] ] > ].

filler-head_wh-inf_phrase := filler-head-wh-phrase & wh-int-clause &
  [ ARGS < [ INFLECTED + ],
           [ SYNSEM.LOCAL.CAT [ HEAD.VFORM inf,
                                VAL.SUBJ < [ OPT +,
                                             LOCAL.CONT.HOOK.INDEX ref-ind,
                                             NON-LOCAL [ SLASH 0-dlist,
                                                         REL 0-dlist,
                                                         QUE 0-dlist ] ] > ] ] > ].

; -- "preguntas eco" - el elemento interrogativo permanece in situ 
; e.g. ¿Lo viste dónde?, ¿María visitó a quién?
;subj-head_wh-insitu_phrase := subj-head-phrase & clause & 
;  [ SYNSEM [ SLSHD #slshd,
;             LOCAL.CONT.HOOK.XARG #ltop,
;             NON-LOCAL [ SLASH 0-dlist,
;                         REL 0-dlist ] ],
;    HEAD-DTR.SYNSEM [ SLSHD #slshd,
;                      LOCAL [ CAT.HEAD verb &
;                                       [ VFORM fin,
;                                         TAM.MOOD ind_or_sub_mood ],
;                              CONT.HOOK [ LTOP #ltop,
;                                          INDEX #ind ] ],
;                      NON-LOCAL [ QUE 1-dlist,
;                                  REL 0-dlist,
;                                  SLASH 0-dlist ] ],
;    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist,
;    C-CONT.HOOK.INDEX #ind ].   
; sbj-hd_wh-insitu_constr := subj-head_wh-insitu_phrase & binary-rule-right-to-left.


; --- filler-head phrase types for non-wh

; i)- focus (foco antepuesto)
; a). may be place to the left peripherical position of the main clause; i.e. may be separated from its clause by other 
; clauses (e.g. Manzanas dijo María que compró Juan) or to the left peripherical position of the subordinated clause 
; (e.g. María dijo que manzanas compró Juan), but it can't be related to any position within a relative, an adverbial 
; and a subject clause (*A Pedro conocemos la mujer que traicionó); b). focus DO can't be doubled by an acc clitic 
; (e.g. el diario (*lo) compró Juan); c). tiene que estar adyacente al verbo (*el diario Pedro lo compró);
; d). puede relacionarse con un pronombre (e.g. su propio auto deberá asegurar cada taxista)      
;
; [sentential topic (vs discourse topic) may be associated to different sentential positions, e.g. subject 
; in passive constructions ('NY es habitada por el rey de Francia), but there are some sentential positions 
; that can only function as topic. This is the case of the left peripherical position we find in hanging topic 
; and left dislocation.]
; ii)- left dislocation ('dislocación a la izquierda')
; a). puede aparecer en la periferia izquierda de la cláusula matriz o de la subordinada; b). existe una dependencia 
; gramatical entre el tema y la posición dentro de la cláusula con la que se relationa; c). el tema no puede relacionarse 
; con un epíteto ni con un pronombre tónico, pero cuando se relaciona con un OD o OI es obligatorio el clítico acc o dat; 
; d). el tema no puede relacionarse con una posición dentro de una cláusula relativa, adverbial o sujeto
; e.g. a sus amigos, María los invitó a cenar
;      estoy segura de que a sus amigos, María los invitó a cenar
;     *estoy segura de que a Pedro, conocemos la mujer que lo traicionó
;
; iii)- hanging topic ('tema vinculante') (may be preceded by the expression 'en cuanto a', 'con respecto a'). 
; a). can only appear in the left peripherical position of the main clause; b). may be related with any position 
; within the sentence which is occupied by a pronominal element (tónico o átono), o un epíteto, o puede tener una 
; relación de tipo inalienable con un sintagma. Esta relación es referencial, no hay dependencia gramatical.
; c). puede entrar en relación con cualquier posición sintáctica dentro de una cl. relativa, adverbial o de sujeto.
; e.g. en cuanto al hermano, parece que los padres lo contemplan mucho/hablan de él constantemente
;      en cuanto a el hermano, parece que el desgraciado se lleva bien con todo el mundo,
;      en cuanto a la capacidad científica del Sr. González, basta con mencionar que este acaba de ganar un premio
;      en cuanto al BMW, parece que los frenos le fallan constantemente
;      (en cuanto a) el Sr. González, conocemos la mujer que lo traicionó 
; !!! not covered

filler-head-non_wh-phrase := filler-head-phrase & mc-fillhead-phrase & non-rel-clause & 
  [ SYNSEM.LOCAL [ COORD #coord,
                   COORD-STRAT #coord-strat,
                   CAT [ MC #mc,
                         HEAD #head,
                         VAL #val ],
                   CONT.HOOK.INDEX.SF #sf ],
    ARGS < [ SYNSEM canonical-synsem &
                    [ LOCAL [ CAT [ HEAD +nvrp,
                                    VAL.SPR < > ],
                              CONT [ HOOK.INDEX #nhind, 
                                     RELS.LIST < relation, ... > ] ],
                      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ],
           [ SYNSEM [ LOCAL [ COORD #coord & -,
                              COORD-STRAT #coord-strat,
                              CAT [ MC #mc,
                                    HEAD #head & verb,
                                    VAL #val ],
                              CONT.HOOK.INDEX #vind & [ SF #sf ] ],
                      NON-LOCAL [ SLASH <! [ CONT.HOOK.INDEX #nhind ] !>,
                                  QUE 0-dlist ] ] ] >,

    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #vind ],
             RELS <! [ ARG0.SF iforce,
                       LBL #ltop,
                       ARG1 #vind,
                       ARG2 #nhind ] !>,
	     HCONS <! !> ] ]
"""
; i)- focus (foco antepuesto)
; a). may be place to the left peripherical position of the main clause; i.e. may be separated from its clause by other 
; clauses (e.g. Manzanas dijo María que compró Juan) or to the left peripherical position of the subordinated clause 
; (e.g. María dijo que manzanas compró Juan), but it can't be related to any position within a relative, an adverbial 
; and a subject clause (*A Pedro conocemos la mujer que traicionó); b). focus DO can't be doubled by an acc clitic 
; (e.g. el diario (*lo) compró Juan); c). tiene que estar adyacente al verbo (*el diario Pedro lo compró);
; d). puede relacionarse con un pronombre (e.g. su propio auto deberá asegurar cada taxista)      
;
; [sentential topic (vs discourse topic) may be associated to different sentential positions, e.g. subject 
; in passive constructions ('NY es habitada por el rey de Francia), but there are some sentential positions 
; that can only function as topic. This is the case of the left peripherical position we find in hanging topic 
; and left dislocation.]
; ii)- left dislocation ('dislocación a la izquierda')
; a). puede aparecer en la periferia izquierda de la cláusula matriz o de la subordinada; b). existe una dependencia 
; gramatical entre el tema y la posición dentro de la cláusula con la que se relationa; c). el tema no puede relacionarse 
; con un epíteto ni con un pronombre tónico, pero cuando se relaciona con un OD o OI es obligatorio el clítico acc o dat; 
; d). el tema no puede relacionarse con una posición dentro de una cláusula relativa, adverbial o sujeto
; e.g. a sus amigos, María los invitó a cenar
;      estoy segura de que a sus amigos, María los invitó a cenar
;     *estoy segura de que a Pedro, conocemos la mujer que lo traicionó
;
; iii)- hanging topic ('tema vinculante') (may be preceded by the expression 'en cuanto a', 'con respecto a'). 
; a). can only appear in the left peripherical position of the main clause; b). may be related with any position 
; within the sentence which is occupied by a pronominal element (tónico o átono), o un epíteto, o puede tener una 
; relación de tipo inalienable con un sintagma. Esta relación es referencial, no hay dependencia gramatical.
; c). puede entrar en relación con cualquier posición sintáctica dentro de una cl. relativa, adverbial o de sujeto.
; e.g. en cuanto al hermano, parece que los padres lo contemplan mucho/hablan de él constantemente
;      en cuanto a el hermano, parece que el desgraciado se lleva bien con todo el mundo,
;      en cuanto a la capacidad científica del Sr. González, basta con mencionar que este acaba de ganar un premio
;      en cuanto al BMW, parece que los frenos le fallan constantemente
;      (en cuanto a) el Sr. González, conocemos la mujer que lo traicionó 
; !!! not covered
""". 
  
filler-head-non_wh_focus-phrase := filler-head-non_wh-phrase & 
  [ C-CONT.RELS <! [ PRED focus_d_rel ] !> ]. 

filler-head_nonwh_phrase := filler-head-non_wh_focus-phrase & filler-head-phrase-fin & 
  [ ARGS < [ INFLECTED + ],
           [ SYNSEM [ SLSHD +, 
                      LOCAL.CAT [ HEAD.VFORM fin,
                                  VAL.SPR < > ] ] ] > ].       

filler-head_nonwh-nfin_phrase := filler-head-non_wh_focus-phrase & filler-head-phrase-nonfin & 
  [ ARGS < [ INFLECTED + ],
           [ SYNSEM.SLSHD + ] > ].


;filler-head_nonwh-fin-sbj-topic_phrase := filler-head-non_wh_focus-phrase & filler-head-phrase-fin & 
;  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD noun & [ CASE nom ] ],
;           [ SYNSEM.LOCAL [ STR.HEADED not_left,
;                            CAT [ HEAD [ VFORM fin, INV - ],
;                                  VAL.SUBJ < > ] ] ] > ].
;
;filler-head_nonwh-fin-sbj_phrase := filler-head-non_wh_focus-phrase & filler-head-phrase-fin & 
;  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD noun & [ CASE nom ] ],
;           [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin, INV + ],
;                                VAL.SUBJ < > ] ] > ].   
;
;filler-head_nonwh-fin-cmp_phrase := filler-head-non_wh_focus-phrase & filler-head-phrase-fin & 
;  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ CASE not-nom, 
;                                     MOD < > ] ],
;           [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin, INV - ],
;                                VAL.SUBJ < > ] ] > ].     
;
; for ATR and LCOMPS e.g. ahí estamos!!!
;filler-head_nonwh-fin-lcmp_phrase := filler-head-non_wh_focus-phrase & filler-head-phrase-fin & 
;  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ CASE not-nom, 
;                                     MOD < [ LOCAL intersective-mod &
;				 	           [ CAT.HEAD noun ] ] > ] ],
;           [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin, INV - ],
;                                VAL.SUBJ < > ] ] > ].   
;
; for completive clauses
;filler-head_nonwh-fin-cmp-cp_phrase := filler-head-non_wh_focus-phrase & filler-head-phrase-fin & 
;  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD +vc ],
;           [ SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin, INV - ],
;                                VAL.SUBJ < > ] ] > ].   
;
;filler-head_nonwh-fin-adj_phrase := filler-head-non_wh_focus-phrase & filler-head-phrase-fin & 
;  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ CASE not-nom,
;                                     MOD < [ LOCAL [ CAT.HEAD verb,
;                                                     CONT.HOOK.INDEX.SF prop ] ] > ] ],
;           [ SYNSEM.LOCAL.CAT [ HEAD.VFORM fin,
;                                VAL.SUBJ < > ] ] > ].      
;
;filler-head_nonwh-nfin-adj_phrase := filler-head-non_wh_focus-phrase & filler-head-phrase-nonfin & 
;  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD [ CASE not-nom,
;                                     MOD < [ LOCAL [ CAT.HEAD verb,
;                                                     CONT.HOOK.INDEX.SF prop ] ] > ] ],
;           [ ] > ].
;flr-hd_nonwh-fin-sbj_constr := filler-head_nonwh-fin-sbj_phrase & binary-rule-left-to-right. 
;flr-hd_nonwh-fin-sbj-tpc_constr := filler-head_nonwh-fin-sbj-topic_phrase & binary-rule-left-to-right. 
;flr-hd_nonwh-fin-cmp_constr := filler-head_nonwh-fin-cmp_phrase & binary-rule-left-to-right.  
;flr-hd_nonwh-fin-lcmp_constr := filler-head_nonwh-fin-lcmp_phrase & binary-rule-left-to-right. 
;flr-hd_nonwh-fin-cmp-cp_constr := filler-head_nonwh-fin-cmp-cp_phrase & binary-rule-left-to-right. 
;flr-hd_nonwh-fin-adj_constr := filler-head_nonwh-fin-adj_phrase & binary-rule-left-to-right. 
;flr-hd_nonwh-nfin-adj_constr := filler-head_nonwh-nfin-adj_phrase & binary-rule-left-to-right. 


; --- filler-head phrase types for Relative Clauses

filler-head-rel-phrase := filler-head-phrase & relative-clause &
  [ INFLECTED +,
    SYNSEM [ LOCAL [ STR [ HEADED right,
                           HEADING no ],
                     CAT [  MC na,
                            HEAD verb & 
                                 [ VFORM #vform,
                                   TAM #tam,
                                   AUX #aux,
                                   INV #inv,
                                   PRD non-prd,
                                   KEYS.KEY #key,
                                   LSYNSEM #lsynsem,
                                   MOD < [ LOCAL intersective-mod &
                                                 [ AGR #ind,
                                                   CONT.HOOK [ LTOP #rhand,
                                                               INDEX #ind ] ] ] > ] ] ],
             NON-LOCAL.REL 1-dlist ],
    ARGS < [ SYNSEM.NON-LOCAL [ QUE 0-dlist,
                                REL 1-dlist & 
                                    [ LIST < [ LTOP #rhand,
                                               XARG #rhand ] > ] ] ],
           [ SYNSEM [ LOCAL [ STR.HEADING right,
                              CAT [ MC -,
                                    HEAD [ VFORM #vform,
                                           TAM #tam,
                                           AUX #aux,
                                           INV #inv,
                                           KEYS.KEY #key,
                                           LSYNSEM #lsynsem ] ],
                              CONT.HOOK [ LTOP #ltop,
                                          INDEX #event & [ SF prop ] ] ],
                      NON-LOCAL [ QUE 0-dlist,
                                  REL 0-dlist ] ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #event ],
             RELS <! !>,
             HCONS <! !> ] ].


filler-head-restr-rel-phrase := filler-head-rel-phrase & 
  [ SYNSEM.LOCAL [ COORD #coord,
                   COORD-STRAT #coord-strat,
                   STR.HEADING no,
                   CAT.HEAD [ VFORM fin_or_inf,
                              MOD < [ PUNCT.RPUNCT no_punct, 
                                      LOCAL.CAT.HEAD noun &
                                                     [ KEYS.KEY nonpro_rel ] ] > ] ],
    ARGS < [ SYNSEM.NON-LOCAL.REL 1-dlist & [ LIST < [ ] > ] ],
           [ INFLECTED +,
             SYNSEM [ PUNCT.LPUNCT no_punct, 
                      LOCAL [ COORD #coord,
                              COORD-STRAT #coord-strat ] ] ] > ]
"""
; --- Restrictive RCs (e.g. la casa tenía [dos [habitaciones [que daban al parque]]])
; - Tiempo/modo:
;   - admiten las construcciones de infinitivo (hallamos el camino por donde escapar) 
;   y subjuntivo (no he conocido jugador que quiera perder)
; - Pronombre relativo:
;   - "el cual" y "quien" sólo pueden aparecer cuando actúan como término de preposición
;   e.g. el periodista a quien se le atribuye.../*el periodista quien dio la noticia...,  
;        donó la pluma con la cual solía escribir/*llevó a reparar la pluma la cual no escribía
;   - "que" puede aparecer como término de ciertas preposiciones sin la concurrencia del artículo
;   e.g. donó la pluma con que solía escribir. 
; - Antecedente:
;   - no pueden tener un antecedente oracional ni preposicional, pero si adverbial 
;   (iremos allá donde tú digas) o pronominal no personal (aquellos en los que aparecían 
;   afirmaciones polémicas han sido retocados)
;   - no modifican un SN cuyo núcleo denote por sí solo entidades referenciales (pron. 
;   personales, nombres propios (excepto si van acompañados de determinantes))
;   e.g. *Él/Luis que estaba en desacuerdo fue destituido fulminantemente
;        El Luís que más me gusta es el que sabe sobreponerse a cualquier dificultad
;   - el antecedente no puede llevar un posesivo prenominal (*su libro con el que estudiamos 
;   está un tanto desfasado
;   - pueden concurrir con antecedentes inespecíficos (no ha venido ningún inspector/nadie 
;   que lo haya autorizado
;   - !!! con antecedente coordinado, los determinantes han de ser de la misma clase
;   e.g. *el dragaminas y una corbeta que cruzaron el estrecho se dirigieron...
;   - !!! en las que modifican un SN indeterminado que ejerce la función de sujeto u objeto, 
;   se puede interpolar entra la cl. relativa y su antecedente material que no corresponda 
;   a la subordinada, sino a la principal, siempre que el antecedente ocupe la posición posverbal.
;   e.g. le entregué una lista a María que contenía los nombres de todos los inscritos
;        de repente, apareció en la sala un individuo que parecía sacado de una película de terror.
""".


filler-head-rel-np-mn-ellip-phrase := filler-head-restr-rel-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD.KEYS [ KEY elliptical_n_rel,
                                                            ALTKEY _el_q_rel ],
                                                VAL.SPR < > ],
                                          CONT.HOOK.INDEX #ind & [ SORT #sort ] ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD noun & [ KEYS.ALTKEY proper_q_rel ],
                                  VAL.SPR < > ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind & [ SORT #sort ] ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - RCs modifying elliptical NPs
; e.g. lo único que importa es esto.
""". 

filler-head_rel-fin-np-mn-ellip_phrase := filler-head-rel-np-mn-ellip-phrase & filler-head-phrase-fin.


filler-head-restr-rel-pname-phrase := filler-head-rel-phrase & 
  [ SYNSEM.LOCAL [ COORD #coord,
                   COORD-STRAT #coord-strat,
                   STR.HEADING no,
                   CAT.HEAD [ VFORM fin_or_inf,
                              MOD < [ PUNCT.RPUNCT no_punct, 
                                      LOCAL [ CAT [ HEAD noun &
                                                         [ KEYS.KEY named_rel ],
                                                    VAL.SPR < [ LOCAL.AGR.PNG.GEN masc_or_fem ] > ],
                                              CONT.HOOK.INDEX #ind & 
                                                              [ DIVISIBLE -, 
                                                                PNG #png & [ PN 3per ],
                                                                SORT #sort & non-temp,
                                                                PRONTYPE not_pron ] ] ] > ] ],
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD noun & [ KEYS.ALTKEY proper_q_rel ],
                                  VAL.SPR < > ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind & 
                                                               [ PNG #png,
                                                                 SORT #sort ] ] > ] ] ],
           [ INFLECTED +,
             SYNSEM [ PUNCT.LPUNCT no_punct, 
                      LOCAL [ COORD #coord,
                              COORD-STRAT #coord-strat ] ] ] > ]
"""
; - RCs modifying proper names
; e.g. El Luís que más me gusta es el que sabe sobreponerse a cualquier dificultad
""".

filler-head_rel-fin-np-mpn_phrase := filler-head-restr-rel-pname-phrase & filler-head-phrase-fin.


filler-head-rel-np-mn-phrase := filler-head-restr-rel-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ VAL.SPR < [ ] > ],
                                          CONT.HOOK.INDEX #ind ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD noun & [ PRD non-prd,
                                                KEYS.ALTKEY proper_q_rel ],
                                  VAL.SPR < > ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - RCs modifying common nouns, NP filler - for subject and DO RCs
; e.g. la casa tenía dos habitaciones que daban al parque; la casa que compramos tenía dos habitaciones
""". 

filler-head_rel-fin-np-mn_phrase := filler-head-rel-np-mn-phrase & filler-head-phrase-fin.
filler-head_rel-inf-np-mn_phrase := filler-head-rel-np-mn-phrase & filler-head-phrase-inf &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.CASE acc ], [ INFLECTED + ] > ].


filler-head-rel-modnp-mn-phrase := filler-head-restr-rel-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD.KEYS.KEY non_modable_rel,
                                              VAL.SPR < [ LOCAL.CONT.HCONS  <! qeq !> ] > ] ] >,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD modnp ],
           [ INFLECTED + ] > ]
"""
; - RCs modifying common nouns, MODNP filler - for lcomp/adjunct RCs
; e.g. recuerdo el modo como llegó, la ciudad donde creció
""". 

filler-head_rel-fin-modnp-mn_phrase := filler-head-rel-modnp-mn-phrase & filler-head-phrase-fin.
filler-head_rel-inf-modnp-mn_phrase := filler-head-rel-modnp-mn-phrase & filler-head-phrase-inf.


filler-head-rel-pp-mn-phrase := filler-head-restr-rel-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD.KEYS.KEY non_modable_rel,
                                                VAL.SPR < [ LOCAL.CONT.HCONS  <! qeq !> ] > ],
                                          CONT.HOOK.INDEX #ind & [ SORT #sort ] ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD adp & [ KEYS [ KEY independent_rel,
                                                    ALT2KEY def_q_rel ] ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind & [ SORT #sort ] ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - RCs modifying common nouns, PP filler - for lcomp/adjunct RCs
; e.g. la ciudad en la que creció, el país hacia el que partió
""". 

filler-head_rel-fin-pp-mn_phrase := filler-head-rel-pp-mn-phrase & filler-head-phrase-fin.
filler-head_rel-inf-pp-mn_phrase := filler-head-rel-pp-mn-phrase & filler-head-phrase-inf.


filler-head-rel-mkn-mn-phrase := filler-head-restr-rel-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD.KEYS.KEY non_modable_rel,
                                                VAL.SPR < [ LOCAL.CONT.RELS  <! relation !> ] > ],
                                          CONT.HOOK.INDEX #ind & [ SORT #sort ] ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD adp & [ KEYS.KEY selected_rel ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind & [ SORT #sort ] ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - RCs modifying common nouns, marked NP filler - for PPcomp RCs
; e.g. la persona en la que más confío
""". 

filler-head_rel-fin-mkn-mn_phrase := filler-head-rel-mkn-mn-phrase & filler-head-phrase-fin.
filler-head_rel-inf-mkn-mn_phrase := filler-head-rel-mkn-mn-phrase & filler-head-phrase-inf.


filler-head-rel-r-mn-phrase := filler-head-restr-rel-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD.KEYS.KEY non_modable_rel,
                                              VAL.SPR < [ LOCAL.CONT.RELS  <! relation !> ] > ] ] >,
    ARGS < [ SYNSEM [ LOCAL [ CAT.HEAD adp,
                              CONT.RELS.LIST.REST.FIRST.PRED state_loc_rel ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX.SORT mod ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - RCs modifying common nouns, prep+donde filler (e.g. la ciudad en donde)
""". 

filler-head_rel-fin-r-mn_phrase := filler-head-rel-r-mn-phrase & filler-head-phrase-fin.
filler-head_rel-inf-r-mn_phrase := filler-head-rel-r-mn-phrase & filler-head-phrase-inf.


filler-head-rel-np-mpr-phrase := filler-head-restr-rel-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD.KEYS [ KEY non_modable_rel,
                                                            ALTKEY def_or_udef_q_rel ],
                                                VAL.SPR < > ],
                                           CONT [ HOOK.INDEX #ind,
                                                  RELS <! relation, quant-relation !> ] ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD noun & [ KEYS.ALTKEY proper_q_rel ],
                                  VAL.SPR < > ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - RCs modifying pronouns, NP filler
; e.g. 
""". 

filler-head_rel-fin-np-mpr_phrase := filler-head-rel-np-mpr-phrase & filler-head-phrase-fin.
filler-head_rel-inf-np-mpr_phrase := filler-head-rel-np-mpr-phrase & filler-head-phrase-inf &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.CASE acc ], [ ] > ].


filler-head-rel-pp-mpr-phrase := filler-head-restr-rel-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD.KEYS.KEY non_modable_rel,
                                                VAL.SPR < > ],
                                          CONT [ HOOK.INDEX #ind,
                                                 RELS <! relation, quant-relation !> ] ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD prep_or_modnp,
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - RCs modifying pronouns, PP filler
; e.g. 
""". 

filler-head_rel-fin-pp-mpr_phrase := filler-head-rel-pp-mpr-phrase & filler-head-phrase-fin.
filler-head_rel-inf-pp-mpr_phrase := filler-head-rel-pp-mpr-phrase & filler-head-phrase-inf.


filler-head-rel-pp-mr-phrase := filler-head-restr-rel-phrase & filler-head-phrase-fin & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD.KEYS.KEY modable_rel,
                                                VAL.SPR < > ] ,
                                          CONT.HOOK.INDEX #ind ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD prep_or_modnp,
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind & [ SORT loc-mod ] ] > ] ] ],
           [ INFLECTED +,
             SYNSEM.LOCAL.CAT.HEAD.VFORM fin ] > ]
"""
; - RCs modifying pronouns, RCs modifying deictic adverbs (only donde) 
; e.g. allá donde estés tú estaré yo)
""".

filler-head_rel-fin-pp-mr_phrase := filler-head-rel-pp-mr-phrase.


; - RCs modifying temporal Ns, NP filler - e.g. el día que dimitió
; filler-head-rel-np-mntmp-phrase := filler-head-restr-rel-phrase &
;   [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT.VAL.SPR < [ LOCAL.CONT.RELS  <! relation !> ] >,
;                                           CONT.HOOK.INDEX.SORT tmp ] ] >,
;     ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD noun & [ KEYS.ALTKEY proper_q_rel ],
;                                   VAL.SPR < > ],
;                       NON-LOCAL.REL 1-dlist & [ LIST < [ ] > ] ] ],
;            [ INFLECTED + ] > ]. 
;  
; filler-head_rel-fin-np-mntmp_phrase := filler-head-rel-np-mntmp-phrase & filler-head-phrase-fin.
; filler-head_rel-inf-np-mntmp_phrase := filler-head-rel-np-mntmp-phrase & filler-head-phrase-inf.
; 
; - RCs modifying temporal Ns, MODNP filler - e.g. el día cuando dimitió
; filler-head-rel-modnp-mntmp-phrase := filler-head-restr-rel-phrase & 
;   [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD.KEYS.KEY modable_rel,
;                                                 VAL.SPR < [ LOCAL.CONT.RELS  <! relation !> ] > ],
;                                           CONT.HOOK.INDEX.SORT tmp ] ] >,
;     ARGS < [ SYNSEM [ LOCAL.CAT.HEAD modnp,
;                       NON-LOCAL.REL 1-dlist & [ LIST < [ ] > ] ] ],
;            [ INFLECTED + ] > ].
; 
; filler-head_rel-fin-modnp-mntmp_phrase := filler-head-rel-modnp-mntmp-phrase & filler-head-phrase-fin.
; filler-head_rel-inf-modnp-mntmp_phrase := filler-head-rel-modnp-mntmp-phrase & filler-head-phrase-inf.
; flr-hd_rel-fin-np-mntmp_constr := filler-head_rel-fin-np-mntmp_phrase & binary-rule-right-to-left.
; flr-hd_rel-inf-np-mntmp_constr := filler-head_rel-inf-np-mntmp_phrase & binary-rule-right-to-left.
; flr-hd_rel-fin-modnp-mntmp_constr := filler-head_rel-fin-modnp-mntmp_phrase & binary-rule-right-to-left.
; flr-hd_rel-inf-modnp-mntmp_constr := filler-head_rel-inf-modnp-mntmp_phrase & binary-rule-right-to-left.


filler-head-nonrestr-rel-phrase := binary-phrase & relative-clause &
  [ SYNSEM phr-synsem & 
           [ SLSHD #slshd,
             LOCAL [ STR [ HEADED right,
                           HEADING no ],
                     CAT [ POSTHEAD +,
                           MC na,
                           HEAD verb & 
                                [ VFORM #vform,
                                  TAM #tam,
                                  AUX #aux,
                                  INV #inv,
                                  PRD non-prd,
                                  LSYNSEM #lsynsem,
                                  KEYS [ KEY #key,
                                         ALTKEY appos-able_rel ],
                                  MOD < [ PUNCT.RPUNCT comma_punct, 
                                          LOCAL intersective-mod &
                                                [ AGR #ind,
                                                  CAT.VAL [ SUBJ < >,
                                                            COMPS < > ],
                                                  CONT.HOOK [ LTOP #rhand,
                                                              INDEX #ind  ] ] ] > ],
                           VAL [ SUBJ #subj,
                                 SPR < >,
                                 COMPS #comps,
                                 CLTS #clit ] ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         REL 1-dlist,
                         QUE 0-dlist ] ],
    ARGS < [ SYNSEM [ LOCAL #slash & local &
                             [ CAT.VAL [ SUBJ olist,
                                         COMPS olist,
                                         CLTS < > ],
                               CTXT.ACTIVATED + ],
                      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 1-dlist & 
                                      [ LIST < [ LTOP #rhand ] > ] ] ] ],
           [ SYNSEM [ PUNCT.LPUNCT comma_or_clause_or_no_punct, 
                      SLSHD #slshd,
                      LOCAL [ CAT [ HEAD verb & 
                                         [ VFORM #vform & fin,
                                           TAM #tam & [ MOOD ind_or_sub_mood ],
                                           AUX #aux,
                                           INV #inv,
                                           LSYNSEM #lsynsem,
                                           KEYS.KEY #key ],
                                    VAL [ SUBJ #subj & < >,
                                          COMPS #comps & < >,
                                          CLTS #clit & < > ],
                                    MC - ],
                              CONT [ HOOK [ LTOP #ltop,
                                            INDEX.SF prop ] ] ],
                      NON-LOCAL [ SLASH 1-dlist &
                                        [ LIST [ FIRST #slash,
                                                 REST < > & #last ],
                                          LAST #last ],
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ] >,
    C-CONT [ HOOK.LTOP #ltop,
             RELS <! !>,
             HCONS <! !> ] ]
"""
; --- Non-restrictive RCs (e.g. La casa tenía [[dos habitaciones],[que daban al parque]])
; - vform and mood
;   - rechazan las construcciones de infinitivo, y, sólo muy esporádicamente, admiten el subjuntivo
;   e.g. *hallamos el camino, por donde escapar
; - Relative pronouns
;   - "el cual" y "quien" pueden aparecer sin restricción alguna.
;   e.g. el periodista, quien dio la noticia, lleva tres días desaparecido
;   llevó a reparar la pluma, la cual no escribía bien.
;   - "que" debe puede concurrir con el artículo cuando aparece como término de ciertas preposiciones
;   e.g. *donó la pluma, con que solía escribir/donó la pluma, con la que solía escribir
; - antecedent:
;   - pueden modificar un SN cuyo núcleo denote por sí solo entidades referenciales (pron. 
;   personales tónico, nombres propios)
;   e.g. Él/Luis, que estaba en desacuerdo, fue destituido fulminantemente
;   - el antecedente puede llevar un posesivo prenominal
;   e.g. su libro, con el que estudiamos, está un tanto desfasado
;   - no pueden concurrir con antecedentes inespecíficos 
;   e.g. *no ha venido nadie, que lo haya autorizado
;   - pueden tener PPs como antecedentes en oraciones en las que la subordinada aparece introducida 
;   por un relativo adverbial (como, cuando, donde)
;   e.g. iremos de vacaciones en la primavera, cuando haya terminado este capítulo 
;   - !!! pueden tener un antecedente oracional (un SN con valor proposicional), en la subordinada el 
;   verbo debe seleccionar una completiva. Si la oración subordinada no lleva un verbo copulativo, es 
;   necesario el artículo neutro
;   e.g. finalmente, abandonó la reunión, que fue lo más prudente 
;        presentó el recuso fuera de plazo, *(lo) que provocó que no fuera admitido
;   - !!! con antecedente coordinado, los determinantes puden ser de distinta clase,
;   e.g. el dragaminas y una corbeta, que cruzaron el estrecho, se dirigieron...
; - !!! extraposición de la cláusula de relativo: la subordinada debe tener un inciso parentético,
; el elemento interpuesto no puede ser confundido con el antecedente
; e.g. me llamó tu primo ayer, que --por cierto-- no sabía que era tu cumpleaños
""".

filler-head_nonrestrel-n-mnp_phrase := filler-head-nonrestr-rel-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD noun & 
                                                     [ KEYS.KEY non_modable_rel ],
                                                VAL.SPR < > ],
                                          CONT.HOOK.INDEX #ind & 
                                                          [ PNG #png,
                                                            SORT #sort ] ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD noun & 
                                       [ KEYS [ KEY non_modable_rel, 
                                                ALTKEY proper_q_rel ] ],
                                  VAL.SPR < > ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind & 
                                                               [ PNG #png,
                                                                 SORT #sort ] ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - NRRCs modifying common/proper nouns, filler "que"
; e.g. La casa tenía [[dos habitaciones],[que daban al parque]]
""". 


filler-head_nonrestrel-np-mnp_phrase := filler-head-nonrestr-rel-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD noun & 
                                                     [ KEYS.KEY non_modable_rel ],
                                                VAL.SPR < > ],
                                          CONT.HOOK.INDEX #ind & 
                                                          [ PNG #png,
                                                            SORT #sort ] ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT [ HEAD noun & 
                                       [ CASE nom,
                                         KEYS [ KEY non_que_pron_rel, 
                                                ALTKEY def_q_rel ] ],
                                  VAL.SPR < > ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind & 
                                                               [ PNG #png,
                                                                 SORT #sort ] ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - NRRCs modifying common/proper nouns, filler "el cual"/"quien"
; e.g. el periodista, quien dio la noticia, desapareció; reparó la pluma, la cual no escribía bien.
""". 


filler-head_nonrestrel-pp-mnp_phrase := filler-head-nonrestr-rel-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD noun & 
                                                     [ KEYS [ KEY non_modable_rel,
                                                              ALTKEY def_q_rel ] ],
                                                VAL.SPR < > ],
                                          CONT.HOOK.INDEX.SORT #sort ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD adp & [ KEYS [ KEY independent_rel,
                                                    ALT2KEY def_q_rel ] ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX.SORT #sort ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - NRRCs modifying common/proper nouns, filler PP
; e.g. donó la pluma, con la que solía escribir
""". 


filler-head_nonrestrel-mkn-mnp_phrase := filler-head-nonrestr-rel-phrase & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD noun & 
                                                     [ KEYS [ KEY non_modable_rel,
                                                              ALTKEY def_q_rel ] ],
                                                VAL.SPR < > ],
                                          CONT.HOOK.INDEX.SORT #sort ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD adp & [ KEYS.KEY selected_rel ],
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX.SORT #sort ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; -  NRRCs modifying common/proper nouns, filler marked NP
; e.g. 
""". 


filler-head_nonrestrel-modnp-mnp_phrase :=  filler-head-nonrestr-rel-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD noun & 
                                                     [ KEYS [ KEY non_modable_rel,
                                                              ALTKEY def_q_rel ] ],
                                              VAL.SPR < > ] ] > ,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD modnp,
                      NON-LOCAL.REL 1-dlist & [ LIST < [ ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - NRRCs modifying common/proper nouns, filler modnp
; e.g. fue hallada en la casa de Comillas, donde vivió en su juventud
""".


filler-head_nonrestrel-modnp-mpp_phrase :=  filler-head-nonrestr-rel-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD +rp,
                                              VAL.SPR < [ ] > ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD modnp,
                      NON-LOCAL.REL 1-dlist & [ LIST < [ ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - NRRCs modifying adverbs/PPs, filler modnp
; e.g. lo hice [discretamente/con precaución], como me había recomendado
""".


filler-head_nonrestrel-modnp-mr_phrase :=  filler-head-nonrestr-rel-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL [ CAT [ HEAD modnp & [ KEYS.KEY modable_rel ],
                                                VAL.SPR < > ],
                                          CONT.HOOK.INDEX #ind ] ] >,
    ARGS < [ SYNSEM [ LOCAL.CAT.HEAD modnp,
                      NON-LOCAL.REL 1-dlist & [ LIST < [ INDEX #ind & [ SORT mod ] ] > ] ] ],
           [ INFLECTED + ] > ]
"""
; - NRRCs modifying modnp, filler modnp
; e.g. lo hice así, como me había recomendado; recuerdo ese día, cuando dimitió
""".


; e.g. vivía sola, como siempre había deseado 


filler-head-free-rel-phrase := binary-phrase & phrasal &
  [ SYNSEM [ SLSHD #slshd,
             LOCAL [ COORD #coord,
                     COORD-STRAT #coord-strat,
                     STR.HEADING no,
                     CAT [ MC na,
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 SPR < >,
                                 CLTS #clit ] ],
                     CONT.HOOK #hook & [ INDEX ref-ind ] ],
             NON-LOCAL [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ],
             LIGHT - ],
    ARGS < [ INFLECTED + ,
             SYNSEM [ LOCAL [ CAT [ HEAD.KEYS.KEY #key,
                                    VAL [ COMPS < >,
                                          SUBJ < > ] ],
                              CONT.RELS.LIST < relation, [ LBL #ltop ], ... > ],
                      NON-LOCAL [ QUE 1-dlist & <! ref-ind !>,
                                  SLASH 1-dlist  &
                                        <! [ CAT.HEAD.KEYS.KEY #key ] !>] ] ],
           [ INFLECTED +,
             SYNSEM [ SLSHD #slshd,
                      LOCAL [ COORD #coord,
                              COORD-STRAT #coord-strat,
                              CAT [ HEAD verb & 
                                         [ VFORM fin_or_inf,
                                           INV - ],
                                    VAL [ SPR < >,
                                          COMPS < >,
                                          CLTS #clit & < > ],
                                    MC - ],
                              CONT.HOOK [ LTOP #ltop,
                                          INDEX.SF prop ] ], 
                      NON-LOCAL [ SLASH 1-dlist &
                                        <! [ CAT.VAL [ COMPS < >,
                                                       SPR < >,
                                                       SUBJ < > ] ] !>,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ] >,
    C-CONT [ HOOK #hook, 
             RELS <! !>,
	     HCONS <! !> ] ]
"""
; --- Free RCs (es el propio pronombre relativo el que delmita, en virtud de sus propios 
; rasgos léxicos, el valor del antecedente). El valor de tales construcciones es el de proyecciones 
; sintagmáticas infraoracionales (SN, SP, SAdv)
; e.g. [quien te dijo eso] no conoce las raíces del conflicto, [con quien me quiero casar] vive aquí, 
;      [donde vive tu hermano] es demasiado lejos para ir de vacaciones (NPs)
;      he soñado [con quien soñé ayer], ayer vi [a quien le compraste el piso] (PPs)
;      este traje lo llevaba [cuando se casó] (SAdv)
; - sólo con "quien" y relativos adverbiales.
; - admiten como máximo una preposición ante el pronombre o adverbio que las encabeza: 
;   - esté doblemente seleccionada: e.g. he soñado con quien soñé ayer, ayer vi a quien se lo compraste
;   - si la preposición corresponde al antecedente elíptico, la construcción es gramatical:
;   e.g. luchó contra quienes se le opusieron
;   - si la preposición está dentro de la relativa: si la relativa forma parte del sujeto 
;   preverbal de la oración principal, la construcción es gramatical (e.g. con quien me quiero 
;   casar vive a la vuelta); si desempeña cualquier otra función, es agramatical, excepto si es el OD
;   (e.g. no tiene con quien salir). Este tipo de r. libres se construyen en infinitivo. 
; ARGS < [ SYNSEM [ LOCAL [ CONT.HOOK.XARG #hand ] ],
;        [ SYNSEM [ LOCAL [ CONT [ HOOK.LTOP #hand ] ] ] >.
""".


filler-head-free-rel-np-arg-phrase := filler-head-free-rel-phrase &
  [ SYNSEM.LOCAL [ AGR #agr,
                   CAT.HEAD #head ],
    ARGS < [ SYNSEM [ LOCAL [ AGR #agr,
                              CAT.HEAD #head & [ KEYS.ALTKEY #altkey ],
                              CONT.RELS.LIST.FIRST.PRED free_relative_q_rel ],
                      NON-LOCAL.SLASH <! #loc !> ] ], 
           [ SYNSEM.NON-LOCAL.SLASH 1-dlist &
                                    <! #loc & 
                                       [ CAT.HEAD.KEYS.ALTKEY #altkey ] !> ] > ]
"""
; - argumental free RC, NP filler 
; e.g. [quien te dijo eso] no conoce las raíces del conflicto
""".

filler-head_free-rel-fin-np-arg_phrase := filler-head-free-rel-np-arg-phrase & filler-head-phrase-fin.


filler-head-free-rel-mkn-arg-phrase := filler-head-free-rel-phrase &
  [ SYNSEM [ LOCAL.CAT.HEAD noun & [ MOD < >, 
                                     KEYS [ KEY #altkey,
                                            ALTKEY free_relative_q_rel ] ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT.HEAD adp & [ MOD < >,
                                               KEYS.ALTKEY #altkey ],
                              CONT.RELS.LIST.FIRST.PRED free_relative_q_rel ],
                      NON-LOCAL.SLASH <! #loc !> ] ],
           [ SYNSEM.NON-LOCAL.SLASH 1-dlist &
                                    <! #loc !> ] > ]
"""
; - argumental free RC, marked NP filler 
; e.g. [con quien me quiero casar] vive aquí, no tiene [con quien salir]
""".

filler-head_free-rel-fin-mkn-arg_phrase := filler-head-free-rel-mkn-arg-phrase & filler-head-phrase-fin & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE nom,
    ARGS < [ ], 
           [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin ] > ].

filler-head_free-rel-inf-mkn-arg_phrase := filler-head-free-rel-mkn-arg-phrase & filler-head-phrase-inf & 
  [ SYNSEM.LOCAL.CAT.HEAD.CASE acc ].


filler-head-free-rel-pp-arg-phrase := filler-head-free-rel-phrase &
  [ SYNSEM [ LOCAL.CAT.HEAD noun & [ MOD < >, 
                                     KEYS [ KEY #altkey,
                                            ALTKEY undef_quant_q_rel ] ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT.HEAD adp & [ MOD < [ ] >,
                                               KEYS.ALTKEY #altkey ],
                              CONT.RELS.LIST.REST.FIRST.PRED free_relative_q_rel ],
                      NON-LOCAL.SLASH <! #loc !> ] ],
           [ SYNSEM.NON-LOCAL.SLASH 1-dlist &
                                    <! #loc & [ CAT.HEAD.MOD < [ ] > ] !> ] > ]
"""
; - argumental free RC, PP filler 
; e.g. no tiene [donde vivir]
""".

filler-head_free-rel-fin-pp-arg_phrase := filler-head-free-rel-pp-arg-phrase & filler-head-phrase-fin & 
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3sg,
                   CAT.HEAD.CASE nom ],
    ARGS < [ ], 
           [ SYNSEM.LOCAL.CAT.HEAD.VFORM fin ] > ].

filler-head_free-rel-inf-pp-arg_phrase := filler-head-free-rel-pp-arg-phrase & filler-head-phrase-inf &
  [ SYNSEM.LOCAL.CAT.HEAD.CASE acc ].


filler-head-free-rel-pp-adj-phrase := filler-head-free-rel-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD #head,
    ARGS < [ SYNSEM [ LOCAL [ CAT.HEAD #head & adp,
                              CONT.RELS.LIST.REST.FIRST.PRED free_relative_q_rel ],
                      NON-LOCAL.SLASH <! [ CAT [ HEAD [ PRD #prd,
                                                        TAM #tam, 
                                                        CASE #case,
                                                        KEYS #keys ],
                                                 VAL #val ],
                                           CONT #cont,
                                           AGR #agr,
                                           CTXT #ctxt ] !> ] ],
           [ SYNSEM.NON-LOCAL.SLASH 1-dlist &
                                    <! [ CAT [ HEAD [ MOD < [ ] >,
                                                      PRD #prd,
                                                      TAM #tam, 
                                                      CASE #case,
                                                      KEYS #keys & [ KEY independent_rel ] ],
                                               VAL #val ],
                                         CONT #cont,
                                         AGR #agr,
                                         CTXT #ctxt ] !> ] > ]
"""
; - adjunct free RCs, PP filler 
; e.g. este traje lo llevaba [cuando se casó]
""".

filler-head_free-rel-fin-pp-adj_phrase := filler-head-free-rel-pp-adj-phrase & filler-head-phrase-fin.
filler-head_free-rel-inf-pp-adj_phrase := filler-head-free-rel-pp-adj-phrase & filler-head-phrase-inf.


; --- Relativas predicativas (la cláusula de relativo funciona como predicado y no como 
; modificador del antecedente, desempeña funciones de complemento predicativo del OD o 
; del sujeto, o bien de atributo)
; e.g. Luis es quien tiene la culpa de todo
; - pueden tener antecedentes nombres propios y pronominales (átonos o tónicos), pero no oracionales, 
; e.g. los había que habían preferido irse al campo
; - contextos en que las relativas parecen concurrir en función de complemento predicativo:
;   - con el predicado existencial "haber", con la función de complemento predicativo del OD, 
;   e.g. hay días que se hacen interminables, los hay que se hacen interminables
;   - con predicados intensionales (querer, buscar, necesitar). La subordinada debe aparecer
;   en subjuntivo o infinitivo. No todos los predicados aceptan este tipo de relativas (desear)
;   e.g. quiere un médico que conozca la medicina china (lo quiere que ...)
;   - con verbos de percepción sensorial (ver, oír), e.g. la vi que salía de casa.
;   - con predicaciones secundarias encabezadas por la prep. con
;   e.g. con maría que se presenta cada dos por tres, resulta imposible concentrarse
;   - con v. transitivos que admiten un c. predicativo del objeto que expresa es estado 
;   de este al producirse el acontecimiento descrito por el v. principal. 
;   e.g. Lo dejaron que no lo hubiera reconocido ni su padre.
;   - con predicados que admiten la concurrencia de un c. predicativo de sujeto
;   e.g. salió de la reunión que no quiso hablar con nadie, nació que parecía un príncipe
;   - rel. predicativas en función de atributo (con verbos de aspecto perfectivo, expresando
;   cualidades episódica y no permanentes)
;   e.g. el café está que arde, se quedó que parecía famélico.
; - !!! entre el antecedente y la relativa puede interponerse otro material de la oración principal,
; pero sólo cuando la relativa aparece detrás del antecedente.
; e.g. hay ocasiones en la vida cotidiada en las que uno no sabe cómo actuar.


; --- Relativas yustapuestas (la cláusula de relativo aparece aislada de su antecedente como 
; enunciado independiente en yuxtaposición)
; e.g. También faltó a la reunión Luís. Al cual, por cierto, le han impuesto una fuerte multa por eso.
;      Se deshizo en excusas. Que nadie había pedido, por cierto.
;      Le gustaría trasladarse a Sitges. Donde, por otra parte, vive ahora Luisa.





; --- Unary phrase types for extraction

basic-extracted-arg-phrase := head-valence-phrase & head-only &
  [ SYNSEM [ LIGHT -,
             LOCAL.CAT.MC #mc,
             NON-LOCAL.SLASH #slash ],
     HEAD-DTR.SYNSEM [ LOCAL.CAT.MC #mc,
                       NON-LOCAL.SLASH #slash ] ].

basic-extracted-subj-phrase := basic-extracted-arg-phrase & 
  [ SYNSEM [ SLSHD #slshd, 
             LOCAL [ STR.HEADED only_solely,
                     CAT.VAL [ SUBJ < >,
		  	       SPR < >,
			       COMPS #comps,
                               CLTS #clts ],
                     CONT #cont ],
	     NON-LOCAL.SLASH.LIST < #local > ],
    HEAD-DTR.SYNSEM [ SLSHD #slshd, 
                      LOCAL [ CAT [ HEAD verb,
                                  VAL [ SUBJ < expressed-non-canonical &
                                               [ LOCAL #local,
		      	                         NON-LOCAL.SLASH 1-dlist ] >,
        		   	  	COMPS #comps & < >,
                                        CLTS #clts & < > ] ],
                            CONT #cont ] ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

extsubj_phrase := basic-extracted-subj-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD [ VFORM fin,
                                       KEYS.KEY v_event_rel ],
                                VAL.SUBJ < [ LOCAL.CAT.HEAD noun & [ CASE nom ] ] > ] ].

; !!! el sujeto de las cláusulas de particio absoluto puede ser relativizado. En estas construcciones,
; que a menudo adoptan la forma de r. yuxtapuestas, el participio debe aparecer delante del pron. relativo 
; e.g. dicho lo cual, el orador recibió un emocionado aplauso 

basic-extracted-comp-phrase := basic-extracted-arg-phrase & head-compositional & 
  [ SYNSEM canonical-synsem &
	   [ LOCAL [ CAT [ VAL [ SUBJ #subj,
                                 SPR #spr,
                                 COMPS #comps,
                                 CLTS #clts ],
                           MC #mc ],
                     CONT #cont ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ #subj,
                                        SPR #spr,
                                        COMPS < gap & [ NON-LOCAL.SLASH #slash ] 
                                                . #comps >,
                                        CLTS #clts ],
                                  MC #mc ],
                            CONT #cont ],
                      NON-LOCAL.SLASH #slash ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

extcomp-a_phrase := basic-extracted-comp-phrase &
  [ SYNSEM.SLSHD -, 
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD adj ].

extcomp-v_phrase := basic-extracted-comp-phrase &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb & [ KEYS.KEY v_event_rel ] ].

extcomp-n_phrase := basic-extracted-comp-phrase &
  [ SYNSEM.SLSHD -, 
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun,
                                  VAL.COMPS < [ OPT +, 
                                                LOCAL.CAT.HEAD.KEYS.KEY _de_p_sel_rel ] > ] ,
                            CONT.HOOK.INDEX.SORT non-temp ] ]
"""
; -- extracción de complementos nominales
; - si aparecen realizados simultáneamente un genitivo subjetivo y otro objetivo, no es 
; posible la relativización de este último (e.g. *al asesino, cuya descripción de María...)
; a menos que el subjetivo aparezca como compl. agente (e.g. al asesino, cuya descripción 
; por parte de María...).

; - cuando el elemento poseído es indeterminado debe expresarse con un SP_de
; e.g. esa novela, de la que acaban de salir varias traducciones, ha tenido un gran éxito
; pero para cubrir "de las ventas totales, el 72% corresponde a la farmacia", quito 
; HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun & [ KEYS.ALTKEY undef_quant_q_rel ],
""".

extcomp-n-df_phrase := head-only & head-compositional &
  [ SYNSEM.SLSHD -, 
    SYNSEM [ LIGHT -,
             LOCAL [ CAT [ MC #mc,
                           HEAD.KEYS.ALTKEY impl_or_proper_q_rel,
                           VAL [ SPR < [ OPT -,
                                         LOCAL [ CAT.HEAD det,
                                                 CONT.RELS.LIST < quant-relation, 
                                                                  prep-relation & [ ARG2 #ind ], ... > ], 
                                         NON-LOCAL.REL #rel & 1-dlist ] >,
                                 SUBJ #subj,
                                 COMPS #comps,
                                 CLTS #clts ] ],
                     CONT #cont ],
             NON-LOCAL [ SLASH #slash,
                         QUE 0-dlist,
                         REL #rel ] ],
    HEAD-DTR.SYNSEM [ LOCAL [ CAT [ MC #mc,
                                    HEAD noun,
                                    VAL [ SPR < [ LOCAL.CONT.RELS.LIST < relation > ] >,
                                          SUBJ #subj,
                                          COMPS < expressed-synsem & 
                                                  [ OPT +,
                                                    LOCAL [ CAT.HEAD.KEYS.KEY _de_p_sel_rel,
                                                            CONT.HOOK.INDEX ref-ind & #ind ],
                                                    NON-LOCAL.SLASH #slash ]
                                                    . #comps >,
                                          CLTS #clts & < > ] ],
                              CONT #cont & [ HOOK.INDEX.SORT non-temp,
                                             RELS.LIST < noun-relation,... > ] ],
		      NON-LOCAL [ SLASH #slash,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ]
"""
; - con SNs determinados sólo puede aparecer "cuyo". Las codas de los partitivos no pueden 
; ser relativizadas a través de cuyo
; e.g. esa novela, cuyas traducciones acaban de salir, ha tenido un gran éxito (subj)
;      tu amigo, cuyas padres conozco perfectamente, es un cretino (DO)
;      en un lugar de la Mancha de cuyo nombre no quiero acordarme... (PPcomp)
""".

basic-extracted-adj-phrase := head-mod-phrase & head-only & phrasal & 
  [ SYNSEM [ LOCAL [ CAT [ POSTHEAD #ph,
                         MC #mc,
                         VAL.SPR #spr ],
                     CONT #cont ],
	     NON-LOCAL.SLASH 1-dlist &
                             <! [ COORD -,
                                  CAT [ HEAD.MOD < [ LOCAL intersective-mod &
                                                           [ CAT [ POSTHEAD #ph,
                                                                   MC #mc,
                                                                   HEAD #head,
                                                                   VAL #val ],
                                                             CONT.HOOK #hook,
                                                             CTXT #ctxt ] ] >,
                                        VAL [ SUBJ olist,
                                              COMPS olist ] ] ] !> ],
    HEAD-DTR.SYNSEM [ LIGHT +,
                      LOCAL [ CAT [ POSTHEAD #ph,
                                    MC #mc,
                                    HEAD #head,
                                    VAL #val & [ SPR #spr ] ],
                              CONT #cont & [ HOOK #hook ],
                              CTXT #ctxt ],
                      NON-LOCAL.SLASH 0-dlist ],
    C-CONT [ HOOK #hook,
	     RELS <! !>,
	     HCONS <! !> ] ]
"""
; verbal adjunct are extracted before canceling the complement because "ayer cumplió usted años"
""".

extadj-v_phrase := basic-extracted-adj-phrase &
  [ SYNSEM [ SLSHD -, 
             LOCAL.CAT [ HEAD.KEYS.KEY v_event_rel,
                         VAL.SUBJ #subj ],
             NON-LOCAL.SLASH <! [ CAT.HEAD prep_or_modnp & 
                                           [ CASE not-nom,
                                             MOD < [ LOCAL.CAT.HEAD verb ] > ] ] !> ],
    HEAD-DTR.SYNSEM [ MODIFIED notmod,
                      LOCAL.CAT [ HEAD verb & [ AUX -, MOD < > ],
                                  VAL.SUBJ #subj ] ] ].

extadj-n_phrase := basic-extracted-adj-phrase &
  [ SYNSEM [ SLSHD -, 
             NON-LOCAL.SLASH <! [ CAT.HEAD.KEYS.KEY _de_p_rel ] !> ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD noun & [ KEYS [ KEY common_nom_rel, 
                                                     ALTKEY undef_quant_q_rel ] ],
                      NON-LOCAL [ REL 0-dlist,
                                  QUE 0-dlist ] ] ]
"""
; (possesivos) - cuando el elemento poseído es indeterminado debe expresarse con un SP_de
; e.g. el vecino del que guardo algunos objetos vendrá mañana.
""".



;; elliptical constructions both for S+S gapping and VP=VP conjunction reduction, 
;; where in both cases the verb is missing from the second conjunct.  
;; The approach is to have a multi-daughter rule where
;; the first daughter is the full S or VP, the second daughter is a 
;; conjunction lexical item, and the remaining two or three daughters are
;; the complements and/or modifiers of the missing verb.

conj_no_verb_phrase := phrase &
  [ SYNSEM [ SLSHD -, 
             LIGHT -,
             LOCAL [ COORD -, 
                     COORD-REL #crel, 
                     CAT [ MC #mc,
                           HEAD verb &
				[ MOD #mod,
                                  VFORM #vform,
				  AUX #aux,
				  INV #inv,
				  TAM.MOOD #mood,
                                  LSYNSEM #lsynsem ],
			   VAL [ SUBJ #subj,
				 SPR #spr,
				 COMPS < >,
				 SPEC < >,
                                 CLTS < > ] ],
		     CONT.HOOK [ INDEX.E #tam,
				 XARG #xarg ] ],
	     NON-LOCAL [ SLASH 0-dlist,
                         QUE 0-dlist,
                         REL 0-dlist ] ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ MC #mc,
                                    HEAD verb &
		        	         [ MOD #mod & < >,
                                           VFORM #vform,
			                   AUX #aux,
			                   INV #inv,
			                   TAM #tam & [ MOOD #mood ],
			                   LSYNSEM #lsynsem & 
                                                   [ LOCAL.CONT [ HOOK.INDEX #index & [ E #tam ],
						                  HCONS #hcons ],
		                                     NON-LOCAL [ SLASH 0-dlist,
                                                                 QUE 0-dlist,
                                                                 REL 0-dlist ],
				                     LKEYS.KEYREL [ PRED #pred,
					 	                    ARG0 #index ] ],
			                  LPRED #pred ],
		                    VAL [ SUBJ #subj,
		    	                  SPR #spr,
			                  COMPS < >,
			                  SPEC < >,
                                          CLTS < > ] ],
		              CONT.HOOK [ LTOP #ltop,
			                  INDEX #lind & [ E #tam ],
			                  XARG #xarg ] ],
		      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ],
	   [ SYNSEM [ LOCAL [ COORD-REL #crel & 
                                        [ L-HNDL #ltop,
                                          L-INDEX #lind,
                                          R-INDEX #lind ],
			      CAT [ HEAD conj,
                                    VAL.COMPS < synsem > ],
			      CONT [ HOOK #hook, 
                                     RELS <! #crel !> ] ],
		      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ],
	   [ SYNSEM [ LOCAL [ COORD -,
                              CAT [ HEAD +nvjrpc, 
				    VAL [ SPR < >, 
					  COMPS < >,
                                          SPEC < >,
                                          CLTS < >  ] ] ],
		      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ],
	   [ SYNSEM [ LOCAL [ COORD -,
                              CAT [ HEAD +nvjrpc, 
				    VAL [ SPR < >, 
					  COMPS < >,
                                          SPEC < >,
                                          CLTS < >  ] ] ],
		      NON-LOCAL [ SLASH 0-dlist,
                                  QUE 0-dlist,
                                  REL 0-dlist ] ] ], ... >,
    C-CONT [ HOOK #hook,
	     HCONS #hcons ] ]
"""
;; elliptical constructions both for S+S gapping and VP=VP conjunction reduction, 
;; where in both cases the verb is missing from the second conjunct.  
;; The approach is to have a multi-daughter rule where
;; the first daughter is the full S or VP, the second daughter is a 
;; conjunction lexical item, and the remaining two or three daughters are
;; the complements and/or modifiers of the missing verb.
""".

conj_reduct_phrase := conj_no_verb_phrase &
  [ ARGS.FIRST.SYNSEM.LOCAL [ CAT [ HEAD.LSYNSEM.LOCAL [ CAT.VAL.SUBJ #subj,
							 CONT.HOOK.XARG #xarg ],
				    VAL.SUBJ #subj & < synsem > ] ],
    C-CONT.HOOK.XARG #xarg ]
"""
;; VP+conj+XP+XP
;;
""".


conj_red_c_c_phrase := conj_reduct_phrase & quad_phrase &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.LSYNSEM [ LOCAL.CAT.VAL.COMPS < #comp1, #comp2 >, 
					     LKEYS.KEYREL.LBL #rltop ] ],
	   [ SYNSEM.LKEYS.KEYREL.R-HNDL #rltop ], 
	   [ SYNSEM #comp1 ], 
	   [ SYNSEM #comp2 ] >,
    C-CONT.RELS <! !> ]
"""
;; Double complement
;;
""".

conj_red_c_c_constr := conj_red_c_c_phrase & quad_rule_left_to_right.

basic_conj_red_x_m_rule := conj_reduct_phrase & quad_phrase &
  [ ARGS < [ SYNSEM [ LOCAL.CAT #vpcat & 
                                [ HEAD.LSYNSEM.LOCAL.CAT.VAL.COMPS < #comp > ],
		      MODIFIED rmod ] ],
	   [ SYNSEM.LKEYS.KEYREL.R-HNDL #rltop ], 
	   [ SYNSEM #comp ], 
	   [ SYNSEM phr-synsem &
		    [ LOCAL [ CAT.HEAD.MOD < synsem &
					     [ LOCAL.CAT #vpcat ] >,
			      CONT.HOOK.LTOP #rltop ] ] ] > ]
"""
;; Final phrase is a modifier
;;
""".

conj_red_x_m_rule := basic_conj_red_x_m_rule &
  [ C-CONT.RELS <! !> ].

basic_conj_red_x_m-int_rule := basic_conj_red_x_m_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.LSYNSEM.LKEYS.KEYREL [ LBL #ltop,
							  ARG0 #index ] ],
	   [ ], [ ],
	   [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL intersective-mod &
						   [ CONT.HOOK 
							 [ LTOP #ltop,
							   INDEX #index ] ] ] >,
			    CONT.HOOK [ LTOP #ltop,
					XARG #index ] ] ] > ]
"""
;; Intersective modifier
""".

conj_red_x_m-int_rule := basic_conj_red_x_m-int_rule & conj_red_x_m_rule.

basic_conj_red_x_m-scop_rule := conj_red_x_m_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.LSYNSEM.LKEYS.KEYREL [ LBL #ltop,
							  ARG0 #index ] ],
	   [ ], [ ],
	   [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL scopal-mod &
					         [ CONT.HOOK [ LTOP #ltop,
						               INDEX #index ] ] ] > ] > ]
"""
;; Scopal modifier
""".

conj_red_c_m-int_constr := conj_red_x_m-int_rule & quad_rule_left_to_right &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.LSYNSEM.LOCAL.CAT.VAL.COMPS < #comp1 > ],
	   [ ],
	   [ SYNSEM #comp1 ], 
	   [ ] > ]
"""
;; Identity of complement followed by intersective modifier
;;
""".

conj_red_c_m-scop_constr := basic_conj_red_x_m-scop_rule & quad_rule_left_to_right &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.LSYNSEM.LOCAL.CAT.VAL.COMPS < #comp1 > ],
	   [ ],
	   [ SYNSEM #comp1 ], 
	   [ ] > ]
"""
;; Identity of complement followed by scopal modifier
;;
""".


basic_conj_nov_subj_rule := conj_no_verb_phrase & quad_rule_left_to_right &
			    quad_phrase &
  [ ARGS < [ SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < >, 
					SPR < > ],
				  MC bool ],
			    CONT.HOOK.INDEX.SF prop-or-ques ] ],
	   [ ], 
	   [ ],
	   [ ] >,
    C-CONT.RELS <! !> ]
"""
;; For sentence-level gapping: S + SnoV
;;
""".

conj_nov_subj_rule := basic_conj_nov_subj_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.LSYNSEM.LOCAL.CAT.VAL.SUBJ < #subj > ],
	   [ ], 
	   [ SYNSEM #subj ],
	   [ ] >,
    C-CONT.RELS <! !> ].


conj_nov_sb_c_rule := conj_nov_subj_rule &
  [ ARGS < [ SYNSEM.LOCAL.CAT.HEAD.LSYNSEM [ LOCAL.CAT.VAL.COMPS < #comp1 >,
					     LKEYS.KEYREL.LBL #rltop ] ],
	   [ SYNSEM.LKEYS.KEYREL.R-HNDL #rltop ], 
	   [ ], 
	   [ SYNSEM #comp1 & [ NON-LOCAL.SLASH.LAST < > ] ] > ]
"""
;; S+and+NP+Comp
;;
""".


conj_nov_sb_m-int_rule := conj_nov_subj_rule &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.LSYNSEM [ LKEYS.KEYREL [ LBL #ltop,
							      ARG0 #index ] ],
		      MODIFIED rmod ] ],
	   [ SYNSEM.LKEYS.KEYREL.R-HNDL #ltop ], 
	   [ ], 
	   [ SYNSEM phr-synsem &
		    [ LOCAL [ CAT.HEAD.MOD < synsem &
					     [ LOCAL intersective-mod &
					      [ CAT.HEAD verb,
						CONT.HOOK
						    [ LTOP #ltop,
						      INDEX #index ] ] ] >,
			      CONT.HOOK [ LTOP #ltop,
					  XARG #index ] ] ] ] > ]
"""
;; S+and+NP+Mod (intersective)
;;
""".

conj_nov_sb_m-scop_rule := conj_nov_subj_rule &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.LSYNSEM [ LKEYS.KEYREL [ LBL #ltop,
							      ARG0 #ind ] ],
		      MODIFIED rmod ] ],
	   [ SYNSEM.LKEYS.KEYREL.R-HNDL #rltop ], 
	   [ ], 
	   [ SYNSEM phr-synsem &
		    [ LOCAL [ CAT.HEAD.MOD < synsem &
					     [ LOCAL scopal-mod &
					       [ CAT.HEAD verb, 
						 CONT.HOOK [ LTOP #ltop,
							     INDEX #ind ] ] ] >,
			      CONT.HOOK.LTOP #rltop ] ] ] > ]
"""
;; S+and+NP+Mod (scopal)
;;
""".


conj_nov_m-int_sb_rule := basic_conj_nov_subj_rule &
  [ ARGS < [ SYNSEM [ LOCAL.CAT.HEAD.LSYNSEM [ LOCAL.CAT.VAL.SUBJ < #subj >,
                                               LKEYS.KEYREL [ LBL #ltop,
							      ARG0 #index ] ],
		      MODIFIED rmod ] ],
	   [ SYNSEM.LKEYS.KEYREL.R-HNDL #ltop ], 
	   [ SYNSEM phr-synsem &
		    [ LOCAL [ CAT.HEAD.MOD < synsem &
					     [ LOCAL intersective-mod &
					      [ CAT.HEAD verb,
						CONT.HOOK
						    [ LTOP #ltop,
						      INDEX #index ] ] ] >,
			      CONT.HOOK [ LTOP #ltop,
					  XARG #index ] ] ] ], 
	   [ SYNSEM #subj ] > ]
"""
;; S+and+Mod+NP (intersective)
;;
""".


vp-vp_crd-red_phrase := coord-phrase & 
  [ SYNSEM [ SLSHD #slshd,
             LOCAL.CAT [ HEAD #head,
                         VAL #val ] ],
    LCOORD-DTR.SYNSEM [ SLSHD #slshd,
                        LOCAL [ CAT [ HEAD #head & verb & 
                                         [ MOD < > ],
                                    VAL #val & 
                                        [ SUBJ < [ ] >,
                                          COMPS < >,
                                          CLTS < > ] ],
                              CONT.HOOK [ INDEX #lind, 
                                          LTOP #lhndl ] ] ],
    RCOORD-DTR.SYNSEM [ LIGHT -,
                        LOCAL [ CAT [ HEAD #head, 
                                      VAL #val ],
                                CONT.HOOK [ LTOP #rhndl, 
                                            INDEX #rind ],
                                COORD-REL [ LBL #lbl,
                                            C-ARG #carg,
                                            L-HNDL #lhndl,
                                            R-HNDL #rhndl,
                                            L-INDEX #lind,
                                            R-INDEX #rind ] ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !>, 
             HOOK [ LTOP #lbl, 
                    INDEX #carg ] ] ]
"""
;;; coordinate reduction
""".


vp-vp_crd-red_constr := vp-vp_crd-red_phrase &  binary-rule-right-to-left. 


; --- Coordination phrase types

coord-phrase := binary-phrase &
  [ SYNSEM [ LIGHT -,
             SLSHD #slshd,
             LOCAL [ COORD-STRAT #cstrat,
                     CAT [ HEAD.KEYS #keys,
                           VAL [ SUBJ #subj,
                                 COMPS #comps,
                                 SPEC #spec,
                                 CLTS #clts ] ] ],
             NON-LOCAL #nlocal ],
    LCOORD-DTR #ldtr & sign & 
               [ SYNSEM [ SLSHD #slshd,
                          LOCAL.CAT [ HEAD.KEYS #keys, 
                                      VAL [ SUBJ #subj,
                                            COMPS #comps,
                                            SPEC #spec,
                                            CLTS #clts ] ],
                          NON-LOCAL #nlocal ] ],
    RCOORD-DTR #rdtr & sign & 
               [ SYNSEM [ LOCAL [ COORD-STRAT #cstrat,
                                  CAT [ VAL [ SUBJ #subj,
                                              COMPS #comps,
                                              SPEC #spec,
                                              CLTS #clts ] ] ],
                          NON-LOCAL #nlocal ] ],
    ARGS < #ldtr, #rdtr > ].

top_or_mid-coord-phrase := coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT one,
    LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #lind,
    RCOORD-DTR.SYNSEM.LOCAL [ COORD-REL [ LBL #lbl,
                                          C-ARG #carg,
                                          L-INDEX #lind,
                                          R-INDEX #rind ],
                              CONT.HOOK.INDEX #rind ],
    C-CONT.HOOK [ LTOP #lbl, 
                  INDEX #carg ] ].

top-coord-phrase := top_or_mid-coord-phrase &
  [ SYNSEM.LOCAL.COORD - ].

mid-coord-phrase := top_or_mid-coord-phrase &
  [ SYNSEM.LOCAL [ COORD +,
                   COORD-REL implicit-coord-rel ],
    LCOORD-DTR.SYNSEM.LOCAL.COORD-STRAT zero ].

bottom-coord-phrase := phrase &
  [ SYNSEM [ LIGHT -,
             SLSHD #slshd,
             NON-LOCAL #nlocal ],
    CONJ-DTR sign & [ SYNSEM.LOCAL.CAT.HEAD conj ],
    NONCONJ-DTR sign & [ SYNSEM [ SLSHD #slshd,
                                  NON-LOCAL #nlocal ] ] ].

basic-binary-bottom-coord-phrase := bottom-coord-phrase & binary-phrase &
  [ SYNSEM [ LOCAL [ COORD +,
                     COORD-REL #crel,
                     COORD-STRAT one,
                     CAT [ HEAD #mod,
                           VAL #val ] ],
             NON-LOCAL #nlocal ],
    CONJ-DTR.SYNSEM [ LOCAL [ COORD-STRAT one,
                              CAT [ HEAD.LEFT < >,
                                    VAL.COMPS < #compl > ],
                              CONT.RELS <! relation !> ],
                      LKEYS.KEYREL #crel ],
    NONCONJ-DTR.SYNSEM #compl & 
                       [ LOCAL [ CAT [ HEAD #mod,
                                       VAL #val ],
                                 CONT.HOOK.INDEX #rind ],
                         NON-LOCAL #nlocal ],
    C-CONT [ HOOK.INDEX #rind,
	     RELS <! !>,
	     HCONS <! !> ] ].

binary-bottom-coord-phrase := basic-binary-bottom-coord-phrase &
  [ NONCONJ-DTR.SYNSEM.LOCAL.COORD - ].

conj-first-bottom-coord-phrase := binary-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT one,
                   STR.HEADED left ],                     
    CONJ-DTR #cdtr,
    NONCONJ-DTR #ncdtr,
    ARGS < #cdtr, #ncdtr > ].

dobl-conj-first-bottom-coord-phrase := basic-binary-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT one,
                   STR.HEADED left ],                     
    CONJ-DTR #cdtr,
    NONCONJ-DTR #ncdtr & [ SYNSEM.LOCAL.COORD + ],
    ARGS < #cdtr, #ncdtr > ].

event-coord-phrase := coord-phrase &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E #tam,
    LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #lhndl,
    RCOORD-DTR.SYNSEM.LOCAL [ COORD-REL [ L-HNDL #lhndl,
                                          R-HNDL #rhndl,
                                          R-INDEX.E #tam ],
                              CONT.HOOK.LTOP #rhndl ] ].


; --- Rules that describe the different kinds of marking strategies used for 
; coordination in various languages.

; -- monopoly*: Mandatory monosyndeton with optional polysyndeton. This is the 
; familiar Indo-European pattern, in which at least one coordinator is mandatory 
; ("A B and C") and more than one is possible ("A and B and C").

monopoly-top-coord-phrase := top-coord-phrase &
  [ SYNSEM.LOCAL.STR.HEADED right,
    LCOORD-DTR.SYNSEM.LOCAL.COORD -,
    RCOORD-DTR.SYNSEM.LOCAL [ COORD +,
                              STR.HEADING right ] ]
"""
; -- monopoly*: Mandatory monosyndeton with optional polysyndeton. This is the 
; familiar Indo-European pattern, in which at least one coordinator is mandatory 
; ("A B and C") and more than one is possible ("A and B and C").
""".

non_advers-monopoly-top-coord-phrase := monopoly-top-coord-phrase & 
  [ LCOORD-DTR.SYNSEM.LOCAL.COORD-STRAT zero_or_one,
    RCOORD-DTR.SYNSEM.LOCAL.COORD-REL.PRED non_advers_coord_rel ].

advers-monopoly-top-coord-phrase := monopoly-top-coord-phrase & 
  [ LCOORD-DTR.SYNSEM.LOCAL.COORD-STRAT zero_or_one,
    RCOORD-DTR.SYNSEM.LOCAL.COORD-REL.PRED advers_coord_rel ].

monopoly-mid-coord-phrase := mid-coord-phrase &
  [ SYNSEM.LOCAL.STR.HEADED right,
    LCOORD-DTR.SYNSEM.LOCAL.COORD -,
    RCOORD-DTR.SYNSEM.LOCAL [ COORD +,
                              STR.HEADING right ] ].


; -- apoly: These rules handle two coordination strategies:
;
; Asyndeton, in which no coordinators appear: "A B C".
;
; Polysyndeton, in which an N-way coordination is marked with  N-1
; coordinators:
;     "A and B and C", not "A B and C"
;
; For both of these, there is NO MID RULE. The difference between
; them is captured in the bottom rule: asyndeton will have a unary
; (and non-inflecting) bottom rule.
;
;apoly-top-coord-phrase := top-coord-phrase &
;  [ LCOORD-DTR.SYNSEM.LOCAL.COORD -,
;    RCOORD-DTR.SYNSEM.LOCAL.COORD + ].


; -- omni: This handles a variety of polysyndeton, called here for
; clarity "omnisyndeton", in which for an N-way coordination, N
; coordinators are required:
;
;     "and A and B and C" or "A and B and C and".
;
; This coordination strategy requires a significantly approach than
; the others. Rather than a single kind of bottom rule, there are two
; kinds. The first kind, still called "bottom", handles the single
; lowest (rightmost) coordinand.  The other kind, called "left",
; handles all other coordinands (it's called "left" because it is
; always the left daughter of a top- or mid- rule).  Because there are
; N coordinators for N coordinands in this strategy, one of the
; conjunctions must contribute *no* coordination relation, or else
; we'd have too many.  The bottom rule is the exceptional one: it
; requires that its conjunction daughter be of type nosem-conj-lex.
;
; The mid- and top- rules are also slightly different from the other
; coordination strategies, in that they take the COORD-REL from the
; *left* daughter instead of the right.
;
; We use it for complex conjunctions

omni-binary-bottom-coord-phrase := bottom-coord-phrase & binary-phrase &
  [ SYNSEM.LOCAL [ COORD +,
                   COORD-REL null-coord-rel,
                   COORD-STRAT two,
                   CAT [ HEAD #mod,
                         VAL #val ] ],
    CONJ-DTR [ SYNSEM.LOCAL [ CAT.HEAD.LEFT < coord_rel >,
                              CONT.RELS <! !> ] ],
    NONCONJ-DTR.SYNSEM.LOCAL [ COORD -,
                               COORD-STRAT zero,
                               CAT [ HEAD #mod,
                                     VAL #val ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ]
"""
; -- omni: This handles a variety of polysyndeton, called here for
; clarity "omnisyndeton", in which for an N-way coordination, N
; coordinators are required:
;
;     "and A and B and C" or "A and B and C and".
;
; This coordination strategy requires a significantly approach than
; the others. Rather than a single kind of bottom rule, there are two
; kinds. The first kind, still called "bottom", handles the single
; lowest (rightmost) coordinand.  The other kind, called "left",
; handles all other coordinands (it's called "left" because it is
; always the left daughter of a top- or mid- rule).  Because there are
; N coordinators for N coordinands in this strategy, one of the
; conjunctions must contribute *no* coordination relation, or else
; we'd have too many.  The bottom rule is the exceptional one: it
; requires that its conjunction daughter be of type nosem-conj-lex.
;
; The mid- and top- rules are also slightly different from the other
; coordination strategies, in that they take the COORD-REL from the
; *left* daughter instead of the right.
;
; We use it for complex conjunctions
""".

omni-conj-first-bottom-coord-phrase := omni-binary-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ STR [ HEADED left,
                         HEADING right ] ],
                     
    CONJ-DTR #cdtr,
    NONCONJ-DTR #ncdtr,
    ARGS < #cdtr, #ncdtr > ].

omni-left-coord-phrase := bottom-coord-phrase.

omni-binary-left-coord-phrase := omni-left-coord-phrase & binary-phrase &
  [ SYNSEM.LOCAL [ COORD +,
                   COORD-REL #crel,
                   COORD-STRAT two,
                   STR [ HEADED left,
                         HEADING not_right ],
                   CAT [ HEAD [ KEYS #keys,
                                MOD #mod ],
                         VAL #val ] ],
    CONJ-DTR.SYNSEM.LOCAL [ COORD-STRAT two,
                            CONT.RELS <! #crel !> ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD [ KEYS #keys,
                                            MOD #mod ],
                                     VAL #val ],
                               COORD -,
                               COORD-STRAT zero,
                               CONT.HOOK.INDEX #rind ],
    C-CONT [ HOOK.INDEX #rind,
	     RELS <! !>,
	     HCONS <! !> ] ].

omni-conj-first-left-coord-phrase := omni-binary-left-coord-phrase &
  [ CONJ-DTR #cdtr,
    NONCONJ-DTR #ncdtr,
    ARGS < #cdtr, #ncdtr > ].

omni-coord-phrase := coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT two,
    LCOORD-DTR omni-binary-left-coord-phrase &
               [ SYNSEM.LOCAL [ COORD-REL [ LBL #lbl,
                                            C-ARG #carg,
                                            L-INDEX #lind,
                                            R-INDEX #rind ],
                                CONT.HOOK.INDEX #lind ] ],
    RCOORD-DTR.SYNSEM.LOCAL [ COORD +,
                              CONT.HOOK.INDEX #rind ],
    C-CONT.HOOK [ LTOP #lbl, 
                  INDEX #carg ] ].

omni-top-coord-phrase := omni-coord-phrase &
  [ SYNSEM.LOCAL [ COORD -,
                   STR.HEADED right ],
    RCOORD-DTR.SYNSEM.LOCAL.STR.HEADING right ].

omni-mid-coord-phrase := omni-coord-phrase &
  [ SYNSEM.LOCAL [ COORD +,
                   STR [ HEADED right,
                         HEADING right ] ],
    RCOORD-DTR.SYNSEM.LOCAL.STR.HEADING right ].


;; para que dos categorías puedan coordinarse, deben tener la misma jerarquía sintáctica 
;; y deben ser semánticamente compatibles. Sólo se pueden coordinar complementos que 
;; cumplan la selección categorial y semántica del núcleo; i.e. no se puede coordinar un objeto 
;; con 'a' y otro sin (*mencionaron a Juan y el libro), ni dos argumentos con preposiciones 
;; distintas (*hablaron con Miguel y de Darío). 

; -- Coordination of nominals

nom-coord-phrase := coord-phrase &
  [ SYNSEM.LOCAL [ AGR.SORT #sort,
                   CAT [ MC na,
                         LASTNMOD #lastnmod,
                         HEAD noun & 
                              [ CASE #case,
                                PRD #prd,
                                MOD < > ],
                         VAL.SPR #spr ],
                   CONT.HOOK.INDEX [ SORT #sort,
                                     PRONTYPE #ptype ] ],
    LCOORD-DTR.SYNSEM canonical-synsem & 
                      [ LOCAL [ AGR.SORT #sort,
                                CAT [ MC na,
                                      LASTNMOD #lastnmod,
                                      HEAD noun & 
                                           [ MOD #mod,
                                             CASE #case,
                                             PRD #prd ],
                                      VAL.SPR #spr ],
                                CONT.HOOK.INDEX [ SORT #sort,
                                                  PRONTYPE #ptype ] ] ],
    RCOORD-DTR.SYNSEM canonical-synsem & 
                      [ LOCAL.CAT [ MC na,
                                    LASTNMOD #lastnmod,
                                    HEAD noun & 
                                         [ MOD #mod,
                                           CASE #case,
                                           PRD #prd ] ] ] ].


; N coordination types

n-top-coord-phrase := nom-coord-phrase & 
  [ SYNSEM.LOCAL [ AGR [ PNG #png,
                         DIVISIBLE + ],
                   CONT.HOOK.INDEX.PNG #png ],
    LCOORD-DTR.SYNSEM.LOCAL [ AGR.PNG #png,
                              CAT [ HEAD.KEYS.KEY non_named_non_modable_rel, 
                                    VAL.SPR < [ ] > ] ],
    RCOORD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY non_named_non_modable_rel,
                                    VAL.SPR < [ ] > ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ]
"""
; N coordination types
; - cuando se coordinan dos nombres concretos, que comparten el determinante, el 
; resultado sólo designa a un objeto con las propiedades designadas por los dos 
; sustantivos. La concordancia con el verbo es en singular (el presidente y 
; vicesecretario del partido llegó/*llegaron con su escolta)
; - cuando se coordinan dos nombres, los elementos que concuerdan y que van en 
; posición prenominal sólo pueden establecer la concordancia con el primer 
; coordinando, no con todo el sintagma (*las/la vida y milagros de los santos, 
; *las/la supuesta razón y motivo)
; - los SSNN escuetos coordinados pueden aparecer como sujetos y complementos
; (traje papel y lápiz, madre e hijo permanecieron poco tiempo de visita). El SN 
; de sujeto siempre se interpreta como definido y el de objeto como indefinido. 
; Sólo aparecen en predicados episódicos (madre e hijo estaban en casa, 
; *madre e hijo eran altos).
""".

n-middle-coord-phrase := nom-coord-phrase & 
  [ SYNSEM.LOCAL [ COORD-REL #crel,
                   AGR [ PNG #png,
                         DIVISIBLE + ],
                   CONT.HOOK.INDEX.PNG #png ],
    LCOORD-DTR.SYNSEM.LOCAL [ AGR.PNG #png,
                              CAT [ HEAD.KEYS.KEY non_named_non_modable_rel,
                                    VAL.SPR < [ ] > ] ],
    RCOORD-DTR.SYNSEM.LOCAL [ COORD-REL [ LBL #lbl,
                                          C-ARG #carg ],
                              CAT [ HEAD.KEYS.KEY non_named_non_modable_rel,
                                    VAL.SPR < [ ] > ] ],
    C-CONT [ RELS <! [ ARG0 #carg, RSTR #lbl ], #crel !>,
	     HCONS <! !> ] ].

n-bottom-coord-phrase := bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-REL.R-INDEX #ind,
                   AGR #agr,
                   CAT [ HEAD noun & [ KEYS.KEY non_named_non_modable_rel ],
                         VAL.SPR < [ LOCAL.CONT.RELS.LIST < relation > ] > ] ],
    NONCONJ-DTR.SYNSEM canonical-synsem & 
                       [ LOCAL [ AGR #agr,
                                 CAT.HEAD noun & [ KEYS.KEY non_named_non_modable_rel ],
                                 CONT.HOOK.INDEX #ind ] ] ].

n-n_crd-advrs_phrase := n-top-coord-phrase & advers-monopoly-top-coord-phrase & 
  [ SYNSEM.LOCAL.STR.HEADING not_left ].

n-n_crd-mono-top_phrase := n-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
n-n_crd-mono-mid_phrase := n-middle-coord-phrase & monopoly-mid-coord-phrase.
n-n_crd-mono-bot_phrase := n-bottom-coord-phrase & conj-first-bottom-coord-phrase.

n-n_crd-omni-top_phrase := n-top-coord-phrase & omni-top-coord-phrase.
n-n_crd-omni-mid_phrase := n-middle-coord-phrase & omni-mid-coord-phrase.
n-n_crd-omni-left_phrase := n-bottom-coord-phrase & omni-conj-first-left-coord-phrase.
n-n_crd-omni-bot_phrase := n-bottom-coord-phrase & omni-conj-first-bottom-coord-phrase.


np-top-coord-phrase := nom-coord-phrase & 
  [ SYNSEM.LOCAL [ AGR [ PNG.PN plur,
                         DIVISIBLE + ],
                   CAT.VAL.SPR < > ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < >,
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ]
"""
; NP coordination types
; - mostly, coordinated subjects are in plural, but there may be partial agreement 
; with one of the subjects when the verb precedes the subject and when the subject denotes
; an abstract entity (en la corte existía/existían el favoritismo y la corrupción). When 
; the coordinated subject includes referential nouns, the verbs must be in plural (el 
; presidente y vicesecretario del partido llegaron/*llegó con su escolta).
; - cuando se coordinan categorías nominales de distinta persona, la concordancia del verbo 
; se determina según los siguientes criterios: la primera persona se impone a las demás 
; (tú y yo vamos, ella y yo vamos) y la segunda se impone a la tercera (tú y él vais).
; - !!! la coordinación de términos preposicionales pronominales han de compartir el caso 
; (para mí/*para él y mí/para el y yo).
; - !!! la coordinación de sintagmas que encabezan relativas e interrogativas sólo es posible 
; si los pronombres se refieren a complementos no argumentales (ese es el hombre con quien, 
; de quien y para el que vive Luis, *un hombre que y al que vio). Se pueden coordinar 
; pronombres que representan argumentos y pronombre que representan modificadores 
;(¿quién y por qué mató al piloto?)
; - si un adjetivo postnominal sigue a una coordinación de nombres, la concordancia
; adopta dos patrones: si el adjetivo concuerda en plural, éste modifica a todo el 
; sintagma ([el pensamiento y la acción] políticos); si sólo modifica a una de las
; partes, debe concordar con esa parte ([el pensamiento y la acció política]). 
""".

3per_np-top-coord-phrase := np-top-coord-phrase.

; for singular NP nodes
; e.g. el fallecido, así como varios heridos, fue trasladado al hopital.
np_sg-top-coord-phrase := nom-coord-phrase & 
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3sg,
                   CAT.VAL.SPR < > ],
    LCOORD-DTR.SYNSEM [ LOCAL [ AGR.PNG.PN 3per,
                                CAT.VAL.SPR < > ] ],
    RCOORD-DTR.SYNSEM [ LOCAL [ AGR.PNG.PN 3per,
                                CAT.VAL.SPR < > ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

1per_np-top-coord-phrase := np-top-coord-phrase & 
  [ SYNSEM.LOCAL.AGR.PNG.PN 1pl,
    RCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 1per ].

2per_right_np-top-coord-phrase := np-top-coord-phrase & 
  [ SYNSEM.LOCAL.AGR.PNG.PN 2pl,
    LCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3per,
    RCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 2per ].

2per_left_np-top-coord-phrase := np-top-coord-phrase & 
  [ SYNSEM.LOCAL.AGR.PNG.PN 2pl,
    LCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 2per,
    RCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3per ].

;3per_np-top-coord-phrase := np-top-coord-phrase & 
;  [ SYNSEM.LOCAL.AGR.PNG.PN 3pl,
;    LCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3per,
;    RCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3per ].

np-middle-coord-phrase := nom-coord-phrase & 
  [ SYNSEM.LOCAL [ COORD-REL #crel,
                   AGR [ PNG.PN plur,
                         DIVISIBLE + ],
                   CAT.VAL.SPR < > ],
    RCOORD-DTR.SYNSEM.LOCAL [ CAT.VAL.SPR < >,
                              COORD-REL [ LBL #lbl,
                                          C-ARG #carg ] ],
    C-CONT [ RELS <! [ ARG0 #carg, RSTR #lbl ], #crel !>,
	     HCONS <! !> ] ].

3per_np-middle-coord-phrase := np-middle-coord-phrase.

1per_np-middle-coord-phrase := np-middle-coord-phrase & 
  [ SYNSEM.LOCAL.AGR.PNG.PN 1pl,
    RCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 1per ].

2per_right_np-middle-coord-phrase := np-middle-coord-phrase & 
  [ SYNSEM.LOCAL.AGR.PNG.PN 2pl,
    LCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3per,
    RCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 2per ].

2per_left_np-middle-coord-phrase := np-middle-coord-phrase & 
  [ SYNSEM.LOCAL.AGR.PNG.PN 2pl,
    LCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 2per,
    RCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3per ].

;3per_np-middle-coord-phrase := np-middle-coord-phrase & 
;  [ SYNSEM.LOCAL.AGR.PNG.PN 3pl,
;    LCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3per,
;    RCOORD-DTR.SYNSEM.LOCAL.AGR.PNG.PN 3per ].

np-bottom-coord-phrase := bottom-coord-phrase &
  [ SYNSEM.LOCAL [ AGR #agr,
                   CAT [ HEAD noun,
                         VAL.SPR < > ],
                   COORD-REL.R-INDEX #index ],
    NONCONJ-DTR.SYNSEM canonical-synsem & 
                       [ LOCAL [ AGR #agr,
                                 CAT.HEAD noun,
                                 CONT.HOOK.INDEX #index ] ] ].


np-np_crd-advrs_phrase := np-top-coord-phrase & advers-monopoly-top-coord-phrase & 
  [ SYNSEM.LOCAL.STR.HEADING not_left ].

np-np_crd-mono-top-1per_phrase := 1per_np-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
np-np_crd-mono-top-2per-right_phrase := 2per_right_np-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
np-np_crd-mono-top-2per-left_phrase := 2per_left_np-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
np-np_crd-mono-top-3per_phrase := 3per_np-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
np-np_crd-mono-top-3sg_phrase := np_sg-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
np-np_crd-mono-mid-1per_phrase := 1per_np-middle-coord-phrase & monopoly-mid-coord-phrase.
np-np_crd-mono-mid-2per-right_phrase := 2per_right_np-middle-coord-phrase & monopoly-mid-coord-phrase.
np-np_crd-mono-mid-2per-left_phrase := 2per_left_np-middle-coord-phrase & monopoly-mid-coord-phrase.
np-np_crd-mono-mid-3per_phrase := 3per_np-middle-coord-phrase & monopoly-mid-coord-phrase.
np-np_crd-mono-bot_phrase := np-bottom-coord-phrase & conj-first-bottom-coord-phrase.

np-np_crd-omni-top_phrase := np-top-coord-phrase & omni-top-coord-phrase.
np-np_crd-omni-mid_phrase := np-middle-coord-phrase & omni-mid-coord-phrase.
np-np_crd-omni-left_phrase := np-bottom-coord-phrase & omni-conj-first-left-coord-phrase.
np-np_crd-omni-bot_phrase := np-bottom-coord-phrase & omni-conj-first-bottom-coord-phrase.


; AP coordination types

adj-coord-phrase := event-coord-phrase &
  [ SYNSEM.LOCAL [ CAT [ MC na,
                         LASTNMOD #lastnmod,
                         POSTHEAD #ph,
                         HEAD adj & [ MOD < [ LOCAL.CONT #cont ] > ],
                         VAL.COMPS < > ],
                   CONT.HOOK.XARG #xarg  ],
    LCOORD-DTR.SYNSEM.LOCAL [ CAT [ LASTNMOD #lastnmod,
                                    POSTHEAD #ph,
                                    HEAD adj & [ MOD < [ LOCAL [ CONT #cont, AGR #agr  ] ] > ] ],
                              CONT.HOOK.XARG #xarg ],
    RCOORD-DTR.SYNSEM.LOCAL [ CAT [ LASTNMOD #lastnmod,
                                    POSTHEAD #ph,
                                    HEAD adj & [ MOD < [ LOCAL [ CONT #cont, AGR #agr ] ] > ] ],
                              CONT.HOOK.XARG #xarg ] ]
"""
; NOTE that in fact qualitative adjectives may be coordinated without restrictions (e.g. 
; el magnífico y único recital, comidas (muy buenas) y (muy baratas), coordination of 
; relational adjectives show some restrictions (productos alemanes y suecos, *producto 
; alemán y sueco, *el verdadero y alemán espía)
""".

adj-top-coord-phrase := adj-coord-phrase &
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

i-adj-top-coord-phrase := adj-top-coord-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL intersective-mod ] >,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL intersective-mod ] > ].

s-adj-top-coord-phrase := adj-top-coord-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL scopal-mod ] >,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL scopal-mod ] > ].

adj-middle-coord-phrase := adj-coord-phrase &
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].

adj-bottom-coord-phrase := bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-REL.R-INDEX #ind,
                   CAT [ MC na,
                         POSTHEAD #ph,
                         HEAD adj,
                         VAL.COMPS < > ],
                   CONT.HOOK.XARG #xarg ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CAT [ MC na,
                                     POSTHEAD #ph,
                                     HEAD adj ],
                               CONT.HOOK [ INDEX #ind,
                                           XARG #xarg ] ] ].

a-a_crd-advrs_phrase := adj-top-coord-phrase & advers-monopoly-top-coord-phrase
"""
; binary (adversative) coordination (guapo pero antipático)
""".

a-a_crd-mono-top_phrase := i-adj-top-coord-phrase & non_advers-monopoly-top-coord-phrase
"""
; multiple monosyndeton/polysyndeton coordination (guapo, (y) listo y simpático) and 
""".
a-a_s-crd-mono-top_phrase := s-adj-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
a-a_crd-mono-mid_phrase := adj-middle-coord-phrase & monopoly-mid-coord-phrase.
a-a_crd-mono-bot_phrase := adj-bottom-coord-phrase & conj-first-bottom-coord-phrase.

a-a_crd-omni-top_phrase := adj-top-coord-phrase & omni-top-coord-phrase
"""
; omnisyndeton coordination (no sólo guapo sino simpático)
""".
a-a_crd-omni-mid_phrase := adj-middle-coord-phrase & omni-mid-coord-phrase.
a-a_crd-omni-left_phrase := adj-bottom-coord-phrase & omni-conj-first-left-coord-phrase.
a-a_crd-omni-bot_phrase := adj-bottom-coord-phrase & omni-conj-first-bottom-coord-phrase.


; ADV coordination types

adv-coord-phrase := event-coord-phrase &
  [ SYNSEM.LOCAL [ CAT [ LASTNMOD #lastnmod,
                         POSTHEAD #ph,
                         HEAD #head & adv,
                         VAL.COMPS < > ],
                   CONT.HOOK.XARG #xarg ],
    LCOORD-DTR.SYNSEM.LOCAL [ CAT [ LASTNMOD #lastnmod,
                                    POSTHEAD #ph,
                                    HEAD #head & 
                                         [ MOD #mod ] ],
                              CONT.HOOK.XARG #xarg ],
    RCOORD-DTR.SYNSEM.LOCAL [ CAT [ LASTNMOD #lastnmod,
                                    POSTHEAD #ph,
                                    HEAD #head & 
                                         [ MOD #mod ] ],
                              CONT.HOOK.XARG #xarg ] ].

adv-top-coord-phrase := adv-coord-phrase &
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ]].

adv-middle-coord-phrase := adv-coord-phrase &
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ]].

adv-bottom-coord-phrase := bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-REL.R-INDEX #ind,
                   CAT [ POSTHEAD #ph,
                         HEAD adv,
                         VAL.COMPS < > ],
                   CONT.HOOK.XARG #xarg ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CAT [ POSTHEAD #ph,
                                     HEAD adv ],
                               CONT.HOOK [ INDEX #ind,
                                           XARG #xarg ] ] ].

; - multiple monosyndeton/polysyndeton coordination & binary (adversative) coordination
r-r_crd-advrs_phrase := adv-top-coord-phrase & advers-monopoly-top-coord-phrase.
r-r_crd-mono-top_phrase := adv-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
r-r_crd-mono-mid_phrase := adv-middle-coord-phrase & monopoly-mid-coord-phrase.
r-r_crd-mono-bot_phrase := adv-bottom-coord-phrase & conj-first-bottom-coord-phrase.

; - omnisyndeton coordination
r-r_crd-omni-top_phrase := adv-top-coord-phrase & omni-top-coord-phrase.
r-r_crd-omni-mid_phrase := adv-middle-coord-phrase & omni-mid-coord-phrase.
r-r_crd-omni-left_phrase := adv-bottom-coord-phrase & omni-conj-first-left-coord-phrase.
r-r_crd-omni-bot_phrase := adv-bottom-coord-phrase & omni-conj-first-bottom-coord-phrase.


; -- Coordination of verbs

cl-coord-phrase := event-coord-phrase & 
  [ SYNSEM [ LOCAL.CAT [ MC #mc,
                         LASTNMOD #lastnmod,
                                    HEAD +vc & 
                                         [ VFORM #vform,
                                           MOD #mod,
                                           PRD #prd ],
                         VAL.SUBJ < > ],
             NON-LOCAL #nlocal & [ SLASH 0-dlist ] ],
    LCOORD-DTR.SYNSEM [ LOCAL.CAT [ MC #mc,
                                    LASTNMOD #lastnmod,
                                    HEAD +vc & 
                                         [ VFORM #vform & fin,
                                           MOD #mod,
                                           PRD #prd ] ],
                        NON-LOCAL #nlocal ],
    RCOORD-DTR.SYNSEM [ LOCAL.CAT [ MC #mc,
                                    LASTNMOD #lastnmod,
                                    HEAD +vc &
                                         [ VFORM #vform,
                                           MOD #mod,
                                           PRD #prd ] ],
                        NON-LOCAL #nlocal ] ]
"""
; S coordination types
; not need to have the same tense and mood (e.g. [Pepa no llegó] y [no pedirá un tinto])
; !!! they may share a complement (los Pérez trajeron, y los invitados se comieron, una 
; ensalada deliciosa)- always between commas
""".

cl-top-coord-phrase := cl-coord-phrase & 
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

cl-middle-coord-phrase := cl-coord-phrase & 
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].

cl-bottom-coord-phrase := bottom-coord-phrase & 
  [ SYNSEM.LOCAL [ COORD-REL.R-INDEX #ind,
                   CAT [ HEAD +vc  & [ VFORM fin ],
                         VAL.SUBJ < > ] ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD +vc,
                               CONT.HOOK.INDEX #ind ] ].


cl-cl_crd-advrs_phrase := cl-top-coord-phrase & advers-monopoly-top-coord-phrase.

sc-sc_crd-mono-top_phrase := cl-top-coord-phrase & non_advers-monopoly-top-coord-phrase & 
  [ LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD comp,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD comp ].
cl-cl_crd-mono-top_phrase := cl-top-coord-phrase & non_advers-monopoly-top-coord-phrase & 
  [ LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD verb,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD verb ].
cl-cl_crd-mono-mid_phrase := cl-middle-coord-phrase & monopoly-mid-coord-phrase.
cl-cl_crd-mono-bot_phrase := cl-bottom-coord-phrase & conj-first-bottom-coord-phrase.

cl-cl_crd-mono-bot-advrs_phrase := cl-bottom-coord-phrase & dobl-conj-first-bottom-coord-phrase.

cl-cl_crd-omni-top_phrase := cl-top-coord-phrase & omni-top-coord-phrase.
cl-cl_crd-omni-mid_phrase := cl-middle-coord-phrase & omni-mid-coord-phrase.
cl-cl_crd-omni-left_phrase := cl-bottom-coord-phrase & omni-conj-first-left-coord-phrase.
cl-cl_crd-omni-bot_phrase := cl-bottom-coord-phrase & omni-conj-first-bottom-coord-phrase.



; VP coordination types

vp-coord-phrase := event-coord-phrase & 
  [ SYNSEM.LOCAL.CAT [ LASTNMOD #lastnmod,
                       MC #mc,
                       HEAD #head & 
                            [ MOD #mod  ],
                       VAL [ SUBJ #subj,
                             COMPS #comps,
                             CLTS #clts ] ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ LASTNMOD #lastnmod,
                                  MC #mc,
                                  HEAD #head & verb & 
                                       [ MOD #mod, 
                                         VFORM #vform ],
                                  VAL [ SUBJ #subj & < [ ] >,
                                        COMPS #comps & < >,
                                        CLTS #clts ] ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT [ MC #mc,
                                  HEAD verb & 
                                       [ KEYS.KEY v_event_rel, 
                                         MOD #mod, 
                                         VFORM #vform ],
                                  VAL [ SUBJ < [ ] >,
                                        COMPS < >,
                                        CLTS < > ] ] ]
"""
; VP coordination types
; - only with the same tense and mood (e.g. Magdalena casi [se tropezó y se cayó/*se cae])
; but "el régimen se tambalea y pronto caerá", so they don't need to have the same tense
""".

vp-top-coord-phrase := vp-coord-phrase & 
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

vp-middle-coord-phrase := vp-coord-phrase & 
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].

vp-bottom-coord-phrase := bottom-coord-phrase & 
  [ SYNSEM.LOCAL [ COORD-REL.R-INDEX #ind,
                   CAT [ HEAD #head,
                         VAL [ SUBJ < [ ] >,
                               COMPS < > ] ] ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD #head & verb,
                               CONT.HOOK.INDEX #ind ] ].


vp-vp_crd-advrs_phrase := vp-top-coord-phrase & advers-monopoly-top-coord-phrase.

vp-vp_crd-mono-top_phrase := vp-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
vp-vp_crd-mono-mid_phrase := vp-middle-coord-phrase & monopoly-mid-coord-phrase.
vp-vp_crd-mono-bot_phrase := vp-bottom-coord-phrase & conj-first-bottom-coord-phrase.

vp-vp_crd-omni-top_phrase := vp-top-coord-phrase & omni-top-coord-phrase.
vp-vp_crd-omni-mid_phrase := vp-middle-coord-phrase & omni-mid-coord-phrase.
vp-vp_crd-omni-left_phrase := vp-bottom-coord-phrase & omni-conj-first-left-coord-phrase.
vp-vp_crd-omni-bot_phrase := vp-bottom-coord-phrase & omni-conj-first-bottom-coord-phrase.


; V coordination types

v-coord-phrase := event-coord-phrase & 
  [ SYNSEM.LOCAL.CAT [ MC #mc,
                       LASTNMOD #lastnmod,
                       HEAD #head,
                       VAL [ SUBJ #subj & < [ ] >,
                             COMPS < #comps >,
                             CLTS #clts ] ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ MC #mc,
                                  LASTNMOD #lastnmod,
                                  HEAD #head & verb &
                                       [ VFORM #vform, 
                                         MOD #mod, 
                                         TAM #tam, 
                                         CLIT #clit ],
                                  VAL [ SUBJ #subj,
                                        COMPS < #comps,... >, 
                                        CLTS #clts ] ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT [ MC #mc,
                                  LASTNMOD #lastnmod,
                                  HEAD verb &
                                       [ VFORM #vform, 
                                         MOD #mod, 
                                         TAM #tam, 
                                         CLIT #clit ],
                                  VAL [ SUBJ #subj,
                                        COMPS < #comps,... >,  
                                        CLTS #clts ] ] ]
"""
; - la coordinación de núcleos verbales es más aceptable en la medida en que los 
; dos verbos se interpretan como relacionados semánticamente (trajo y se llevó un 
; paquete). El segundo complemento puede ser opcional y de distinto tipo
; - se pueden coordinar verbos que llevan cliticos (lo leyó y resumió en un santiamén,
; intentarlo comprar o alquilar) pero (*lee y resúmelo cuanto antes, *lo pensó y dijo).
; - los verbos auxiliaries funcionales (*hemos y han llamado) presentan más restricciones 
; que los modales (pueden y quieren salir), los aspectuales (comenzó y terminó de hablar)
; y los prospectivos  los modales (quieren y van a seguir viniendo). Pero un elemento 
; proclitico (preposición) no puede preceder a la conjunción (*van a y quieren seguir)
""".

v-top-coord-phrase := v-coord-phrase & 
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

v-middle-coord-phrase := v-coord-phrase & 
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].

v-bottom-coord-phrase := bottom-coord-phrase & 
  [ SYNSEM.LOCAL [ COORD-REL.R-INDEX #ind,
                   CAT [ HEAD verb,
                         VAL [ SUBJ < [ ] >,
                               COMPS < [ ] > ] ] ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CAT.HEAD verb,
                               CONT.HOOK.INDEX #ind ] ].


v-v_crd-advrs_phrase := v-top-coord-phrase & advers-monopoly-top-coord-phrase.

v-v_crd-mono-top_phrase := v-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
v-v_crd-mono-mid_phrase := v-middle-coord-phrase & monopoly-mid-coord-phrase.
v-v_crd-mono-bot_phrase := v-bottom-coord-phrase & conj-first-bottom-coord-phrase.

v-v_crd-omni-top_phrase := v-top-coord-phrase & omni-top-coord-phrase.
v-v_crd-omni-mid_phrase := v-middle-coord-phrase & omni-mid-coord-phrase.
v-v_crd-omni-left_phrase := v-bottom-coord-phrase & omni-conj-first-left-coord-phrase.
v-v_crd-omni-bot_phrase := v-bottom-coord-phrase & omni-conj-first-bottom-coord-phrase.


; VPinf and completive clauses coordination types - AGR: singular
; - if they function as subject, the VP must precede the clause (e.g. venir Juan y que 
; se quedara dos semanas resultó buena idea); 
; - if they function as DO the VP may follow the finite clause (e.g. sugirió que hicieran 
; una fiesta e invitar a sus amigos)

; PP coordination types

prep-coord-phrase := coord-phrase &
  [ SYNSEM.LOCAL.CAT [ MC #mc,
                       LASTNMOD #lastnmod,
                       POSTHEAD #ph,
                       HEAD adp & 
                            [ MOD #mod,
                              TAM #tam, 
                              PRD #prd ],
                       VAL.SPR #spr ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ MC #mc,
                                  LASTNMOD #lastnmod,
                                  POSTHEAD #ph,
                                  HEAD adp & 
                                       [ MOD #mod,
                                         TAM #tam, 
                                         PRD #prd ],
                                  VAL.SPR #spr ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT [ MC #mc,
                                  LASTNMOD #lastnmod,
                                  POSTHEAD #ph,
                                  HEAD adp  & 
                                       [ MOD #mod,
                                         TAM #tam, 
                                         PRD #prd ] ] ]
"""
; - !!! coordinación de dos complementos preposicionales con un adjetivo (que cada uno 
; disponga [[del espacio y de la tierra] necesarios]).
; - es posible coordinar ciertas preposiciones (todo por, para y sin el pueblo). Las 
; preposiciones con menos contenido semántico y menos peso fonológico (a, de, en) 
; son menos aceptables en coordinación (viajan *de y a Madrid/desde y hacia Madrid)
""".

mod-prep-coord-phrase := prep-coord-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY prep_mod_rel,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY prep_mod_rel,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY prep_mod_rel ].

prep-top-coord-phrase := mod-prep-coord-phrase &
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

prep-middle-coord-phrase := mod-prep-coord-phrase &
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].

prep-bottom-coord-phrase := bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-REL.R-INDEX #ind,
                   CAT.MC #mc ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CAT [ MC #mc,
                                     HEAD adp ],
                               CONT.HOOK.INDEX #ind ] ].

mrk-prep-coord-phrase := prep-coord-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY selected_prep_rel,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY selected_prep_rel,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.KEYS.KEY selected_prep_rel ].


mrk-prep-top-coord-phrase := mrk-prep-coord-phrase &
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

mrk-prep-middle-coord-phrase := mrk-prep-coord-phrase &
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].


mkp-mkp_crd-advrs_phrase := mrk-prep-top-coord-phrase & advers-monopoly-top-coord-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

mkp-mkp_crd-mono-top_phrase := mrk-prep-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
mkp-mkp_crd-mono-mid_phrase := mrk-prep-middle-coord-phrase & monopoly-mid-coord-phrase.


pp-pp_crd-advrs_phrase := prep-top-coord-phrase & advers-monopoly-top-coord-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

p-p_crd-mono-top_phrase := prep-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
p-p_crd-mono-mid_phrase := prep-middle-coord-phrase & monopoly-mid-coord-phrase.
p-p_crd-mono-bot_phrase := prep-bottom-coord-phrase & conj-first-bottom-coord-phrase.

pp-pp_crd-omni-top_phrase := prep-top-coord-phrase & omni-top-coord-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].
pp-pp_crd-omni-mid_phrase := prep-middle-coord-phrase & omni-mid-coord-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].
pp-pp_crd-omni-left_phrase := prep-bottom-coord-phrase & omni-conj-first-left-coord-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].
pp-pp_crd-omni-bot_phrase := prep-bottom-coord-phrase & omni-conj-first-bottom-coord-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].


interj_interj-coord-phrase := event-coord-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD interj,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD interj,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD interj ]
"""
; INTERJ-INTERJ coordination types (e.g. je, je)
""".

interj_interj-top-coord-phrase := interj_interj-coord-phrase &
  [  LCOORD-DTR.SYNSEM.LIGHT +,
     C-CONT [ RELS <! !>,
	      HCONS <! !> ]].

interj_interj-middle-coord-phrase := interj_interj-coord-phrase &
  [ SYNSEM.LOCAL.COORD-REL #crel,
    LCOORD-DTR.SYNSEM.LIGHT +,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].

interj-bottom-coord-phrase := bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-REL.R-INDEX #ind,
                   CAT.MC #mc ],
    NONCONJ-DTR.SYNSEM [ LIGHT +,
                         LOCAL [ CAT [ MC #mc,
                                       HEAD interj ],
                                 CONT.HOOK.INDEX #ind ] ] ].

i-i_crd-mono-top_phrase := interj_interj-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
i-i_crd-mono-mid_phrase := interj_interj-middle-coord-phrase & monopoly-mid-coord-phrase.
i-i_crd-mono-bot_phrase := interj-bottom-coord-phrase & conj-first-bottom-coord-phrase.

; DET coordination types

d-top-coord-phrase := coord-phrase & 
  [ SYNSEM.LOCAL [ AGR [ PNG.GEN #gen,
                         DIVISIBLE #div ] ],
    LCOORD-DTR.SYNSEM.LOCAL [ AGR [ PNG.GEN #gen,
                                    DIVISIBLE #div ],
                              CAT [ HEAD.KEYS.KEY non_named_non_modable_rel, 
                                    VAL.SPR #spr ] ],
    RCOORD-DTR.SYNSEM.LOCAL [ CAT [ HEAD.KEYS.KEY non_named_non_modable_rel,
                                    VAL.SPR #spr ] ],
    C-CONT [ RELS <! !>,
	     HCONS <! !> ] ]
"""
; DET coordination types
; - los demostrativos pueden coordinarse (este y ese participante deben presentarse 
; en la oficina) y yo creo que los artículos también (el y la estudiente desarrollan 
; la creatividad, el y la estudiante explore diferentes posibilidades)
""".

d-bottom-coord-phrase := bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-REL.R-INDEX #ind,
                   AGR #agr,
                   CAT.HEAD det ],
    NONCONJ-DTR.SYNSEM canonical-synsem & 
                       [ LOCAL [ AGR #agr,
                                 CAT.HEAD det,
                                 CONT.HOOK.INDEX #ind ] ] ].

d-d_crd-mono-top_phrase := d-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
d-d_crd-mono-bot_phrase := d-bottom-coord-phrase & conj-first-bottom-coord-phrase.


; Coordination of unlike categories
 
#|
nom_verb-coord-phrase := coord-phrase &
  [ SYNSEM.LOCAL [ AGR.PNG.PN 3per,
                   CAT [ POSTHEAD #ph,
                         HEAD noun & [ KEYS.KEY nominalization_rel ],
                         VAL [ SUBJ < >,
                               COMPS < > ] ] ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD noun,
                                  VAL.SPR < > ],
    RCOORD-DTR.SYNSEM.LOCAL [ CAT [ HEAD comp & [ VFORM fin,
                                                  MOD < >  ],
                                    VAL [ SUBJ < >,
                                          COMPS < >,
                                          SPR < > ] ],
                              CONT.HOOK.INDEX event ] ].

n_v-top-coord-phrase := nom_verb-coord-phrase &
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ]].

n_v-middle-coord-phrase := nom_verb-coord-phrase &
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].

n_v_crd-mono-top_phrase := n_v-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
n_v_crd-mono-mid_phrase := n_v-middle-coord-phrase & monopoly-mid-coord-phrase
"""
; Finite completive clauses and VPs may be coordinated with eventive nouns 
; (e.g. odio las llegadas de Segundino y que Cecilia se niegue a verlo), but not 
; with non-event nouns (e.g. *odio a Segundino y que Cecilia se niegue a verlo) 
; unless they are interpreted as two separate events (e.g. Qué cosas te gustaron 
; más del viaje? El avión y que el piloto nos mostrara las ciudades durante la ruta)
; Agreement: singular
""".
|#

adjprep-coord-phrase := event-coord-phrase &
  [ SYNSEM.LOCAL [ CAT [ POSTHEAD #ph,
                         LASTNMOD #lastnmod,
                         VAL.COMPS < > ] ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ LASTNMOD #lastnmod,
                                  HEAD.MOD #mod ],
    RCOORD-DTR.SYNSEM.LOCAL [ CAT [ POSTHEAD #ph,
                                    HEAD.MOD #mod ] ] ]
"""
; ADV-PP coordination types
; - si no son complementos, no se rige el criterio de compatibilidad semántica y similitud 
; jerárquica (e.g. va al médico frecuentemente y sin pretexto)
""".

adjprep-top-coord-phrase := adjprep-coord-phrase &
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

adjprep-middle-coord-phrase := adjprep-coord-phrase &
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].

adj_prep-coord-phrase := advprep-coord-phrase &
  [ SYNSEM.LOCAL [ AGR #agr,
                   CAT.HEAD adj ],
    LCOORD-DTR.SYNSEM.LOCAL [ AGR #agr,
                              CAT.HEAD adj ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD adp ].

prep_adj-coord-phrase := advprep-coord-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD adp,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD adp,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD adj ].


a_p_crd-mono-top_phrase := adjprep-top-coord-phrase & adj_prep-coord-phrase & non_advers-monopoly-top-coord-phrase.
a_p_crd-mono-mid_phrase := adjprep-middle-coord-phrase & adj_prep-coord-phrase & monopoly-mid-coord-phrase.

p_a_crd-mono-top_phrase := adjprep-top-coord-phrase & prep_adj-coord-phrase & non_advers-monopoly-top-coord-phrase.
p_a_crd-mono-mid_phrase := adjprep-middle-coord-phrase & prep_adj-coord-phrase & monopoly-mid-coord-phrase.

; ADV-PP coordination types

advprep-coord-phrase := event-coord-phrase &
  [ SYNSEM.LOCAL [ AGR #agr,
                   CAT [ POSTHEAD #ph,
                         LASTNMOD #lastnmod,
                         VAL.COMPS < > ] ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ LASTNMOD #lastnmod,
                                  HEAD.MOD #mod ],
    RCOORD-DTR.SYNSEM.LOCAL [ AGR #agr,
                              CAT [ POSTHEAD #ph,
                                    HEAD.MOD #mod ] ] ]
"""
; - si no son complementos, no se rige el criterio de compatibilidad semántica y similitud 
; jerárquica (e.g. va al médico frecuentemente y sin pretexto)
""".

advprep-top-coord-phrase := advprep-coord-phrase &
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ] ].

advprep-middle-coord-phrase := advprep-coord-phrase &
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].

adv_prep-coord-phrase := advprep-coord-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD adv,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD adv,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD adp ].

prep_adv-coord-phrase := advprep-coord-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD adp,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD adp,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD adv ].


r_p_crd-mono-top_phrase := advprep-top-coord-phrase & adv_prep-coord-phrase & non_advers-monopoly-top-coord-phrase.
r_p_crd-mono-mid_phrase := advprep-middle-coord-phrase & adv_prep-coord-phrase & monopoly-mid-coord-phrase.

p_r_crd-mono-top_phrase := advprep-top-coord-phrase & prep_adv-coord-phrase & non_advers-monopoly-top-coord-phrase.
p_r_crd-mono-mid_phrase := advprep-middle-coord-phrase & prep_adv-coord-phrase & monopoly-mid-coord-phrase.


adj_adv-coord-phrase := event-coord-phrase &
  [ SYNSEM.LOCAL [ CAT [ POSTHEAD #ph,
                         LASTNMOD #lastnmod,
                         HEAD adv,
                         VAL.COMPS < > ] ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD adj,
    RCOORD-DTR.SYNSEM.LOCAL [ CAT [ POSTHEAD #ph,
                                    LASTNMOD #lastnmod,
                                    HEAD adv ] ] ]
"""
; ADJ-ADV coordination types (e.g. comimos maravillosa y estupendamente)
""".

adj_adv-top-coord-phrase := adj_adv-coord-phrase &
  [ C-CONT [ RELS <! !>,
	     HCONS <! !> ]].

adj_adv-middle-coord-phrase := adj_adv-coord-phrase &
  [ SYNSEM.LOCAL.COORD-REL #crel,
    C-CONT [ RELS <! #crel !>,
	     HCONS <! !> ] ].

a_r_crd-mono-top_phrase := adj_adv-top-coord-phrase & non_advers-monopoly-top-coord-phrase.
a_r_crd-mono-mid_phrase := adj_adv-middle-coord-phrase & monopoly-mid-coord-phrase.



; --- 2. Construction types

optsbj_dcl_constr := optsubj_phrase & clause & rule.
optcmp_r_constr := optcomp-r_phrase & rule. 
optcmp_a_constr := optcomp-a_phrase & rule. 
optcmp_n_constr := optcomp-n_phrase & rule. 
optcmp_v_constr := optcomp-v_phrase & rule. 
optsp_constr := optspec_phrase & rule. 

extsbj_constr := extsubj_phrase & rule. 
extcmp_a_constr := extcomp-a_phrase & rule. 
extcmp_v_constr := extcomp-v_phrase & rule. 
extcmp_n_constr:= extcomp-n_phrase & rule. 
extcmp_n-df_constr := extcomp-n-df_phrase & rule. 
extad_v_constr := extadj-v_phrase & rule. 
extad_n_constr := extadj-n_phrase & rule. 

nbar_constr := nbar_phrase & rule.
nbar-crd_constr := nbar-coord_phrase & rule.
nbar-rel_constr := nbar-rel_phrase & rule.
npred_constr := npred_phrase & rule.

adjpart_constr := adjpart_phrase & rule.
prdp_constr := prdp_phrase & rule.
npadv_constr := npadv_phrase & rule.
npadv_modn_constr := npadv_modn_phrase & rule.
;npadv_pp_constr := pp_npadv_phrase & rule.
vocnp_prh_constr := vocative_np_prh_phrase & rule.
vocnp_psth_constr := vocative_np_psth_phrase & rule.
part_num_constr := partitive_num_phrase & rule.
vger_constr := vger_phrase & rule.
cpa_constr := cpa_phrase & rule.
cpnom_constr := cp-nom_phrase & rule.
vpnom_constr := vp-nom_phrase & rule.

sbj-hd_constr := subj-head_nonque_phrase & declarative-clause & binary-rule-right-to-left. ; ***
hd-sbj_constr := head-subj_phrase & declarative-clause & binary-rule-left-to-right.
hd-sbj_imp_constr := head-subj_imperative_phrase & imperative-clause & binary-rule-left-to-right.
hd-sbj_rc_constr := head-subj_rel_phrase & declarative-clause & binary-rule-left-to-right.
hd-sbj_cpa_constr := head-subj_cpa_phrase & declarative-clause & binary-rule-left-to-right.
hd-sbj_inf_constr := head-subj_vpinf_phrase & declarative-clause & binary-rule-left-to-right.
hd-sbj_crd_constr := head-subj_coord_phrase & declarative-clause & binary-rule-right-to-left. ; ***

hd-cmp_x-xp_constr := head-comp_x-xp_phrase & binary-rule-right-to-left. ; ***
hd-cmp_second_constr := head-comp_second_phrase & binary-rule-left-to-right. 
hd-cmp_x-cl_constr := head-comp_x-cl_phrase & binary-rule-left-to-right. 
hd-cmp_v-cl_constr := head-comp_v-cl_phrase & binary-rule-left-to-right. 
hd-cmp_v-cl-slash_constr := head-comp_v-cl-slash_phrase & binary-rule-left-to-right.
hd-mrk_constr := head-marker_phrase & binary-rule-left-to-right. 
;hd-cmp_aux-vp_constr := head-comp_aux-vp_phrase & binary-rule-left-to-right.
;cmp-hd_constr := comp-head_phrase & binary-rule-right-to-left. 

hd-sp_constr := head-spec_phrase & binary-rule-right-to-left. ; ***
sp-hd_constr := spec-head_phrase & binary-rule-left-to-right. ; ***
sp-hd_hdrel_constr := spec-head_hdrel_phrase & binary-rule-left-to-right. ; ***
sp-hd_hddet_constr := spec-head_hddet_phrase & binary-rule-left-to-right. ; ***
sp-hd_sprel_constr := spec-head_specrel_phrase & binary-rule-left-to-right. ; ***
sp-hd_spdeg_constr := spec-head_specdeg_phrase & binary-rule-left-to-right. ; ***
np_ell_constr := np_ell_phrase & binary-rule-right-to-left.
np_ell-indef_constr := np_ell-indef_phrase & binary-rule-right-to-left.
np_ell-sfrel_constr := np_ell-sfrel_phrase & binary-rule-right-to-left.

; *** all ad-hd below changed from right-to-left to left-to-right

ad-hd_s_constr := adj-head_scop_phrase & binary-rule-left-to-right.
ad-hd_i-xp-xp_constr := adj-head_int-xp-xp_phrase & binary-rule-left-to-right.
ad-hd_i-xp-n_constr := adj-head_int-xp-n_phrase & binary-rule-left-to-right.
ad-hd_i-adv-s_constr := adj-head_int-adv-s_phrase & binary-rule-left-to-right.
ad-hd_i-vp-vp_constr := adj-head_int-vp-vp_phrase & binary-rule-left-to-right.
ad-hd_i-pp-vp_constr := adj-head_int-pp-vp_phrase & binary-rule-left-to-right.
ad-hd_i-adv-vp_constr := adj-head_int-adv-vp_phrase & binary-rule-left-to-right.
ad-hd_i-modnp-vp_constr := adj-head_int-modnp-vp_phrase & binary-rule-left-to-right.

; *** all hd-ad below changed from left-to-right to right-to-left

hd-ad_s-xp-cl_constr := head-adj_scop-xp-cl_phrase & binary-rule-right-to-left.
hd-ad_s-xp-xp_constr := head-adj_scop-xp-xp_phrase & binary-rule-right-to-left.
hd-ad_i-ap-xp_constr := head-adj_int-ap-xp_phrase & binary-rule-right-to-left.
hd-ad_i-pp-xp_constr := head-adj_int-pp-xp_phrase & binary-rule-right-to-left.
hd-ad_i-v-adv_constr := head-adj_int-v-adv_phrase & binary-rule-right-to-left.
hd-ad_i-s-xp_constr := head-adj_int-s-xp_phrase & binary-rule-right-to-left.
hd-ad_i-v-pp_constr := head-adj_int-v-pp_phrase & binary-rule-right-to-left.
hd-ad_i-v-modnp_constr := head-adj_int-v-modnp_phrase & binary-rule-right-to-left.
hd-ad_i-v-vger_constr := head-adj_int-v-vger_phrase & binary-rule-right-to-left.
hd-ad_i-v-frel_constr := head-adj_int-v-frel_phrase & binary-rule-right-to-left.
hd-ad_i-cn-ap_constr := head-adj_int-cn-ap_phrase & binary-rule-right-to-left.
hd-ad_i-cn-pp_constr := head-adj_int-cn-pp_phrase & binary-rule-right-to-left.
hd-ad_i-cn-vger_constr := head-adj_int-cn-vger_phrase & binary-rule-right-to-left.
hd-ad_i-np-pp_constr := head-adj_int-np-pp_phrase & binary-rule-right-to-left.
hd-ad_i-np-xp-crd_constr := head-adj_int-np-xp-crd_phrase & binary-rule-right-to-left.
hd-ad_i-np-xp-pt_constr := head-adj_int-np-xp-pct_phrase & binary-rule-right-to-left.
hd-ad_i-pn-xp_constr := head-adj_int-pn-xp_phrase & binary-rule-right-to-left.
hd-ad_i-pn-xp-pt_constr := head-adj_int-pn-xp-pt_phrase & binary-rule-right-to-left.
hd-ad_i-pr-xp_constr := head-adj_int-pr-xp_phrase & binary-rule-right-to-left.
hd-ad_i-n-rc_constr := head-adj_int-n-rc_phrase & binary-rule-right-to-left.
hd-ad_i-pn-rc_constr := head-adj_int-pn-rc_phrase & binary-rule-right-to-left.
hd-ad_i-pr-rc_constr := head-adj_int-pr-rc_phrase & binary-rule-right-to-left.
hd-ad_i-n-rcpp_constr := head-adj_int-n-rcpp_phrase & binary-rule-right-to-left.
hd-ad_i-pn-rcpp_constr := head-adj_int-pn-rcpp_phrase & binary-rule-right-to-left.
hd-ad_i-pr-rcpp_constr := head-adj_int-pr-rcpp_phrase & binary-rule-right-to-left.
hd-ad_i-n-rcnr_constr := head-adj_int-n-rcnr_phrase & binary-rule-right-to-left.
hd-ad_i-brckt-appos_constr := head-adj_int-bracket-appos_phrase & binary-rule-right-to-left. 

; *** most hd-ad -appos below reverted to left-to-right

hd-ad_i-cn-cn-appos_constr := head-adj_int-cn-cn-appos_phrase & binary-rule-left-to-right. 
hd-ad_i-cn-cn-cln-appos_constr := head-adj_int-cn-cn-cln-appos_phrase & binary-rule-left-to-right. 
hd-ad_i-pn-cn-appos_constr := head-adj_int-pn-cn-appos_phrase & binary-rule-left-to-right. 
hd-ad_i-cn-pn-appos_constr := head-adj_int-cn-pn-appos_phrase & binary-rule-right-to-left. 
hd-ad_i-modnp-appos_constr := head-adj_int-modnp-appos_phrase & binary-rule-left-to-right. 
hd-ad_i-modnp-adv-appos_constr := head-adj_int-modnp-adv-appos_phrase & binary-rule-left-to-right. 
hd-ad_i-nu-appos_constr := head-adj_int-nu-appos_phrase & binary-rule-left-to-right. 
hd-ad_i-cmp-nu-appos_constr := head-adj_int-cmp-nu-appos_phrase & binary-rule-left-to-right. 
n_n_cmpnd_constr := n_n_cmpnd_phrase & binary-rule-left-to-right. 
n_n-nu_cmpnd_constr := n_n-num_cmpnd_phrase & binary-rule-left-to-right. 

flr-hd_wh-fin_constr := filler-head_wh-fin_phrase & binary-rule-left-to-right. 

; *** flr-hd_wh-inf_constr onwards changed from left-to-right to right-to-left

flr-hd_wh-inf_constr := filler-head_wh-inf_phrase & binary-rule-right-to-left.  
flr-hd_nonwh_constr := filler-head_nonwh_phrase & binary-rule-right-to-left. 
flr-hd_nonwh-nfin_constr := filler-head_nonwh-nfin_phrase & binary-rule-right-to-left. 

; *** flr-hd_rel-fin-np-mn-ellip_constr onwards changed from right-to-left to left-to-right

flr-hd_rel-fin-np-mn-ellip_constr := filler-head_rel-fin-np-mn-ellip_phrase & binary-rule-left-to-right.
flr-hd_rel-fin-np-mpn_constr := filler-head_rel-fin-np-mpn_phrase & binary-rule-left-to-right.
flr-hd_rel-fin-np-mn_constr := filler-head_rel-fin-np-mn_phrase & binary-rule-left-to-right.
flr-hd_rel-inf-np-mn_constr := filler-head_rel-inf-np-mn_phrase & binary-rule-left-to-right.
flr-hd_rel-fin-modnp-mn_constr := filler-head_rel-fin-modnp-mn_phrase & binary-rule-left-to-right.
flr-hd_rel-inf-modnp-mn_constr := filler-head_rel-inf-modnp-mn_phrase & binary-rule-left-to-right.
flr-hd_rel-fin-pp-mn_constr := filler-head_rel-fin-pp-mn_phrase & binary-rule-left-to-right.
flr-hd_rel-inf-pp-mn_constr := filler-head_rel-inf-pp-mn_phrase & binary-rule-left-to-right.
flr-hd_rel-fin-mkn-mn_constr := filler-head_rel-fin-mkn-mn_phrase & binary-rule-left-to-right.
flr-hd_rel-inf-mkn-mn_constr := filler-head_rel-inf-mkn-mn_phrase & binary-rule-left-to-right.
flr-hd_rel-fin-r-mn_constr := filler-head_rel-fin-r-mn_phrase & binary-rule-left-to-right.
flr-hd_rel-inf-r-mn_constr := filler-head_rel-inf-r-mn_phrase & binary-rule-left-to-right.
flr-hd_rel-fin-np-mpr_constr := filler-head_rel-fin-np-mpr_phrase & binary-rule-left-to-right.
flr-hd_rel-inf-np-mpr_constr := filler-head_rel-inf-np-mpr_phrase & binary-rule-left-to-right.
flr-hd_rel-fin-pp-mpr_constr := filler-head_rel-fin-pp-mpr_phrase & binary-rule-left-to-right.
flr-hd_rel-inf-pp-mpr_constr := filler-head_rel-inf-pp-mpr_phrase & binary-rule-left-to-right.
flr-hd_rel-fin-pp-mr_constr := filler-head_rel-fin-pp-mr_phrase & binary-rule-left-to-right.
flr-hd_nrrel-n-mnp_constr := filler-head_nonrestrel-n-mnp_phrase & binary-rule-left-to-right.
flr-hd_nrrel-np-mnp_constr := filler-head_nonrestrel-np-mnp_phrase & binary-rule-left-to-right.
flr-hd_nrrel-pp-mnp_constr := filler-head_nonrestrel-pp-mnp_phrase & binary-rule-left-to-right.
flr-hd_nrrel-mkn-mnp_constr := filler-head_nonrestrel-mkn-mnp_phrase & binary-rule-left-to-right.
flr-hd_nrrel-modnp-mnp_constr := filler-head_nonrestrel-modnp-mnp_phrase & binary-rule-left-to-right.
flr-hd_nrrel-modnp-mpp_constr := filler-head_nonrestrel-modnp-mpp_phrase & binary-rule-left-to-right.
flr-hd_nrrel-modnp-mr_constr := filler-head_nonrestrel-modnp-mr_phrase & binary-rule-left-to-right.
flr-hd_frel-fin-np-arg_constr := filler-head_free-rel-fin-np-arg_phrase & binary-rule-left-to-right.
flr-hd_frel-fin-mkn-arg_constr := filler-head_free-rel-fin-mkn-arg_phrase & binary-rule-left-to-right.
flr-hd_frel-inf-mkn-arg_constr := filler-head_free-rel-inf-mkn-arg_phrase & binary-rule-left-to-right.
flr-hd_frel-fin-pp-arg_constr := filler-head_free-rel-fin-pp-arg_phrase & binary-rule-left-to-right.
flr-hd_frel-inf-pp-arg_constr := filler-head_free-rel-inf-pp-arg_phrase & binary-rule-left-to-right.
flr-hd_frel-fin-pp-adj_constr := filler-head_free-rel-fin-pp-adj_phrase & binary-rule-left-to-right.
flr-hd_frel-inf-pp-adj_constr := filler-head_free-rel-inf-pp-adj_phrase & binary-rule-left-to-right.

ct-hd_constr := clit-head_phrase & binary-rule-left-to-right. ; ***
ct-hd_cl_constr := clit-head_phrase_cl & binary-rule-left-to-right. ; ***

interj_constr := interj-phrase & rule. 
interj_improp_constr := interj-impropias-phrase & rule. 

hd-pt_ind_constr := head-punct_ind_phrase & binary-rule-right-to-left.
pt-hd_ev_constr := punct-head_ev_phrase & binary-rule-left-to-right.
pt-hd_ind_constr := punct-head_ind_phrase & binary-rule-left-to-right.
hd-pt_ev_constr := head-punct_ev_phrase & binary-rule-left-to-right.
pt-hd_clt_constr := punct-head_clt_phrase & binary-rule-left-to-right.

; *** crd mono-bot/omni-bot/omni-left changed from right-to-left to left-to-right

n-n_crd-advrs_constr := n-n_crd-advrs_phrase & binary-rule-right-to-left.
n-n_crd-mono-top_constr := n-n_crd-mono-top_phrase & binary-rule-right-to-left.
n-n_crd-mono-mid_constr := n-n_crd-mono-mid_phrase & binary-rule-right-to-left.
n-n_crd-mono-bot_constr := n-n_crd-mono-bot_phrase & binary-rule-left-to-right.
n-n_crd-omni-top_constr := n-n_crd-omni-top_phrase & binary-rule-right-to-left.
n-n_crd-omni-mid_constr := n-n_crd-omni-mid_phrase & binary-rule-right-to-left.
n-n_crd-omni-left_constr := n-n_crd-omni-left_phrase & binary-rule-left-to-right.
n-n_crd-omni-bot_constr := n-n_crd-omni-bot_phrase & binary-rule-left-to-right.
np-np_crd-advrs_constr := np-np_crd-advrs_phrase & binary-rule-right-to-left.
np-np_crd-mono-top-1per_constr := np-np_crd-mono-top-1per_phrase & binary-rule-right-to-left.
np-np_crd-mono-top-2per-right_constr := np-np_crd-mono-top-2per-right_phrase & binary-rule-right-to-left.
np-np_crd-mono-top-2per-left_constr := np-np_crd-mono-top-2per-left_phrase & binary-rule-right-to-left.
np-np_crd-mono-top-3per_constr := np-np_crd-mono-top-3per_phrase & binary-rule-right-to-left.
np-np_crd-mono-top-3sg_constr := np-np_crd-mono-top-3sg_phrase & binary-rule-right-to-left.
np-np_crd-mono-mid-1per_constr := np-np_crd-mono-mid-1per_phrase & binary-rule-right-to-left.
np-np_crd-mono-mid-2per-right_constr := np-np_crd-mono-mid-2per-right_phrase & binary-rule-right-to-left.
np-np_crd-mono-mid-2per-left_constr := np-np_crd-mono-mid-2per-left_phrase & binary-rule-right-to-left.
np-np_crd-mono-mid-3per_constr := np-np_crd-mono-mid-3per_phrase & binary-rule-right-to-left.
np-np_crd-mono-bot_constr := np-np_crd-mono-bot_phrase & binary-rule-left-to-right.
np-np_crd-omni-top_constr := np-np_crd-omni-top_phrase & binary-rule-right-to-left.
np-np_crd-omni-mid_constr := np-np_crd-omni-mid_phrase & binary-rule-right-to-left.
np-np_crd-omni-left_constr := np-np_crd-omni-left_phrase & binary-rule-left-to-right.
np-np_crd-omni-bot_constr := np-np_crd-omni-bot_phrase & binary-rule-left-to-right.
a-a_crd-advrs_constr := a-a_crd-advrs_phrase & binary-rule-right-to-left.
a-a_crd-mono-top_constr := a-a_crd-mono-top_phrase & binary-rule-right-to-left.
a-a_s-crd-mono-top_constr := a-a_s-crd-mono-top_phrase & binary-rule-right-to-left.
a-a_crd-mono-mid_constr := a-a_crd-mono-mid_phrase & binary-rule-right-to-left.
a-a_crd-mono-bot_constr := a-a_crd-mono-bot_phrase & binary-rule-left-to-right.
a-a_crd-omni-top_constr := a-a_crd-omni-top_phrase & binary-rule-right-to-left.
a-a_crd-omni-mid_constr := a-a_crd-omni-mid_phrase & binary-rule-right-to-left.
a-a_crd-omni-left_constr := a-a_crd-omni-left_phrase & binary-rule-left-to-right.
a-a_crd-omni-bot_constr := a-a_crd-omni-bot_phrase & binary-rule-left-to-right.
r-r_crd-advrs_constr := r-r_crd-advrs_phrase & binary-rule-right-to-left.
r-r_crd-mono-top_constr := r-r_crd-mono-top_phrase & binary-rule-right-to-left.
r-r_crd-mono-mid_constr := r-r_crd-mono-mid_phrase & binary-rule-right-to-left.
r-r_crd-mono-bot_constr := r-r_crd-mono-bot_phrase & binary-rule-left-to-right.
r-r_crd-omni-top_constr := r-r_crd-omni-top_phrase & binary-rule-right-to-left.
r-r_crd-omni-mid_constr := r-r_crd-omni-mid_phrase & binary-rule-right-to-left.
r-r_crd-omni-left_constr := r-r_crd-omni-left_phrase & binary-rule-left-to-right.
r-r_crd-omni-bot_constr := r-r_crd-omni-bot_phrase & binary-rule-left-to-right.
cl-cl_crd-advrs_constr := cl-cl_crd-advrs_phrase & binary-rule-right-to-left.
sc-sc_crd-mono-top_constr := sc-sc_crd-mono-top_phrase & binary-rule-right-to-left.
cl-cl_crd-mono-top_constr := cl-cl_crd-mono-top_phrase & binary-rule-right-to-left.
cl-cl_crd-mono-mid_constr := cl-cl_crd-mono-mid_phrase & binary-rule-right-to-left.
cl-cl_crd-mono-bot_constr := cl-cl_crd-mono-bot_phrase & binary-rule-left-to-right.
cl-cl_crd-mono-bot-advrs_constr := cl-cl_crd-mono-bot-advrs_phrase & binary-rule-left-to-right.
cl-cl_crd-omni-top_constr := cl-cl_crd-omni-top_phrase & binary-rule-right-to-left.
cl-cl_crd-omni-mid_constr := cl-cl_crd-omni-mid_phrase & binary-rule-right-to-left.
cl-cl_crd-omni-left_constr := cl-cl_crd-omni-left_phrase & binary-rule-left-to-right.
cl-cl_crd-omni-bot_constr := cl-cl_crd-omni-bot_phrase & binary-rule-left-to-right.
vp-vp_crd-advrs_constr := vp-vp_crd-advrs_phrase & binary-rule-right-to-left.
vp-vp_crd-mono-top_constr := vp-vp_crd-mono-top_phrase & binary-rule-right-to-left.
vp-vp_crd-mono-mid_constr := vp-vp_crd-mono-mid_phrase & binary-rule-right-to-left.
vp-vp_crd-mono-bot_constr := vp-vp_crd-mono-bot_phrase & binary-rule-left-to-right.
vp-vp_crd-omni-top_constr := vp-vp_crd-omni-top_phrase & binary-rule-right-to-left.
vp-vp_crd-omni-mid_constr := vp-vp_crd-omni-mid_phrase & binary-rule-right-to-left.
vp-vp_crd-omni-left_constr := vp-vp_crd-omni-left_phrase & binary-rule-left-to-right.
vp-vp_crd-omni-bot_constr := vp-vp_crd-omni-bot_phrase & binary-rule-left-to-right.
v-v_crd-advrs_constr := v-v_crd-advrs_phrase & binary-rule-right-to-left.
v-v_crd-mono-top_constr := v-v_crd-mono-top_phrase & binary-rule-right-to-left.
v-v_crd-mono-mid_constr := v-v_crd-mono-mid_phrase & binary-rule-right-to-left.
v-v_crd-mono-bot_constr := v-v_crd-mono-bot_phrase & binary-rule-left-to-right.
v-v_crd-omni-top_constr := v-v_crd-omni-top_phrase & binary-rule-right-to-left.
v-v_crd-omni-mid_constr := v-v_crd-omni-mid_phrase & binary-rule-right-to-left.
v-v_crd-omni-left_constr := v-v_crd-omni-left_phrase & binary-rule-left-to-right.
v-v_crd-omni-bot_constr := v-v_crd-omni-bot_phrase & binary-rule-left-to-right.
mkp-mkp_crd-advrs_constr := mkp-mkp_crd-advrs_phrase & binary-rule-right-to-left.
mkp-mkp_crd-mono-top_constr := mkp-mkp_crd-mono-top_phrase & binary-rule-right-to-left.
mkp-mkp_crd-mono-mid_constr := mkp-mkp_crd-mono-mid_phrase & binary-rule-right-to-left.
pp-pp_crd-advrs_constr := pp-pp_crd-advrs_phrase & binary-rule-right-to-left.
p-p_crd-mono-top_constr := p-p_crd-mono-top_phrase & binary-rule-right-to-left.
p-p_crd-mono-mid_constr := p-p_crd-mono-mid_phrase & binary-rule-right-to-left.
p-p_crd-mono-bot_constr := p-p_crd-mono-bot_phrase & binary-rule-left-to-right.
pp-pp_crd-omni-top_constr := pp-pp_crd-omni-top_phrase & binary-rule-right-to-left.
pp-pp_crd-omni-mid_constr := pp-pp_crd-omni-mid_phrase & binary-rule-right-to-left.
pp-pp_crd-omni-left_constr := pp-pp_crd-omni-left_phrase & binary-rule-left-to-right.
pp-pp_crd-omni-bot_constr := pp-pp_crd-omni-bot_phrase & binary-rule-left-to-right.
i-i_crd-mono-top_constr := i-i_crd-mono-top_phrase & binary-rule-right-to-left.
i-i_crd-mono-mid_constr := i-i_crd-mono-mid_phrase & binary-rule-right-to-left.
i-i_crd-mono-bot_constr := i-i_crd-mono-bot_phrase & binary-rule-left-to-right.
d-d_crd-mono-top_constr := d-d_crd-mono-top_phrase & binary-rule-right-to-left.
d-d_crd-mono-bot_constr := d-d_crd-mono-bot_phrase & binary-rule-left-to-right.
a_p_crd-mono-top_constr := a_p_crd-mono-top_phrase & binary-rule-right-to-left.
a_p_crd-mono-mid_constr := a_p_crd-mono-mid_phrase & binary-rule-right-to-left.
p_a_crd-mono-top_constr := p_a_crd-mono-top_phrase & binary-rule-right-to-left.
p_a_crd-mono-mid_constr := p_a_crd-mono-mid_phrase & binary-rule-right-to-left.
r_p_crd-mono-top_constr := r_p_crd-mono-top_phrase & binary-rule-right-to-left.
r_p_crd-mono-mid_constr := r_p_crd-mono-mid_phrase & binary-rule-right-to-left.
p_r_crd-mono-top_constr := p_r_crd-mono-top_phrase & binary-rule-right-to-left.
p_r_crd-mono-mid_constr := p_r_crd-mono-mid_phrase & binary-rule-right-to-left.
a_r_crd-mono-top_constr := a_r_crd-mono-top_phrase & binary-rule-right-to-left.
a_r_crd-mono-mid_constr := a_r_crd-mono-mid_phrase & binary-rule-right-to-left.
